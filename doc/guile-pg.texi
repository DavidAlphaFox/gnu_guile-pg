\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename guile-pg.info
@settitle @code{Guile-pg} Command Reference
@c %**end of header
@code{}
@setchapternewpage odd

@dircategory Guile modules
@direntry
* Guile-pg: (guile-pg).           Access to PostgreSQL databases from Guile.
@end direntry

@ifinfo
This file is the Guile-pg Command Reference

Copyright @copyright{} 1998, 2002 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and
print the results, provided the printed document carries a copying
permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{@code{Guile-pg} Command Reference}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998, 2002 Free Software Foundation, Inc.

     Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice are
preserved on all copies.

     Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled ``Copying'' and ``GNU General Public
License'' are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@c ---------------------------------------------------------------------------
@node Top
@top  Guile-pg

@code{Guile-pg} is a Guile module providing a set of procedures to allow
access to the PostgreSQL RDBMS from Scheme programs.

Guile is an interpreter for the Scheme programming language: a dialect of
Lisp.  PostgreSQL is a free SQL database management system.
@code{Guile-pg} is intended as but one of the low-level drivers for the
forthcoming Guile database module which will provide a portable interface
to many different SQL database servers.  In the mean-time
it will still be a useful module for those who want just a low-level
interface to PostgreSQL.

The @code{Guile-pg} procedures have an almost one-one correspondence
with the PostgreSQL @code{libpq} C library interface so those familiar with
the @code{libpq} library and other similar interfaces like Edmund Mergl's
@code{Pg} Perl module will find it familiar.

@code{Guile-pg} is based on Russ McManus's ``Sybase glue'' code.

@menu
* Legalities::                  Your rights and freedoms.
* Quick Start::                 Overview and brief examples.

* Database Connections::        Groundwork for database interaction.
* Retrieving Data::             Making queries and accessing results.
* Writing/Reading Data::        Bulk data movement and I/O.
* Large Objects::               Large-Object support.
* Miscellaneous::               Everything else starting with "pg-".

* Types Conversion::            Module: (database postgres-types).
* Single-Table Abstraction::    Module: (database postgres-table).

* Procedure Index::
@end menu

@c ---------------------------------------------------------------------------
@node    Legalities
@chapter Legalities

Guile-PG is released under the GNU General Public License; a copy of this
document is included in the distribution as file @file{COPYING}.

Please support free software by visiting @url{http://www.gnu.org} and
contributing fixes and other improvements to guile-pg.

@c ---------------------------------------------------------------------------
@node    Quick Start
@chapter Quick Start

To access a PostgreSQL database from Guile, first load the @code{postgres}
database module. This is done using the @code{use-modules} syntax:
@example
     (use-modules (database postgres))
@end example

The next step is to make a connection to the database using the
@code{pg-connectdb} procedure. Then, having created a valid connection to a
database server, we can use the @code{pg-exec} procedure to execute
queries and the other @code{pg-} procedures to retrieve the results of the
queries.

The following Guile session opens a connection and executes an
SQL statement on the @code{test} database on the default host (either
@code{localhost} or the host specified in the @code{PGHOST} environment
variable.)

@cartouche
@example
guile> (use-modules (database postgres))
guile> (define test (pg-connectdb "dbname=test"))
guile> test
#<PG-CONN:1:test::5432:>
guile> (define result (pg-exec test "SELECT * FROM PEOPLE"))
guile> result
#<PG-RESULT:1:PGRES_TUPLES_OK:3:5>
@end example
@end cartouche

The @code{test} object is a @code{PG-CONN} type representing the database
connection.  Displaying the @code{PG-CONN} object shows that the serial number
of the connection is 1, that the database name is @code{test} on the default
host (the hostname field is empty) on port number 5432 and that the default
options were passed to the backend.  This object is passed to @code{pg-exec}
which returns a @code{PG-RESULT} object representing the result of the SQL
statement executed on the server.  In this case, displaying the @code{PG-RESULT}
object shows us that the serial number of the result is 2, that the return code
from the database was @code{PGRES_TUPLES_OK} and that we have received 3 tuples
with 5 fields.

Having obtained a result object from the database we can find out how
many rows and how many columns are in the result.  We can also find out the
names of the columns:

@cartouche
@example
guile> (pg-ntuples result)
3
guile> (pg-nfields result)
5
guile> (pg-fname result 0)
"surname"
guile> (pg-fname result 1)
"firstname"
@end example
@end cartouche

To retrieve the data from the result we use the @code{pg-getvalue} procedure.
This takes a result object along with the row and column numbers and returns a
string containing that value.  @code{pg-getvalue} always returns a string: it
is up to the caller to convert this to whatever type they require.

@cartouche
@example
guile> (pg-getvalue result 0 0)
"Bitdiddle"
guile> (pg-getvalue result 0 1)
"Ben"
guile> (pg-getvalue result 1 0)
"Ator"
guile> (pg-getvalue result 1 1)
"Eva Lu"
@end example
@end cartouche

@code{Guile-pg} connections are closed when Guile's garbage collector
collects the discarded object.  This only happens when the connection itself
and all of the results of @code{pg-exec} are unreachable.  So to close the
connection we just rebind the results from that connection and the connection
symbol itself:

@cartouche
@example
guile> (define result '())
guile> (define test '())
@end example
@end cartouche

Typically though the result and connection variables will be @code{let}
bindings so the connection will usually be closed soon after the body of the
@code{let} returns.

@c ---------------------------------------------------------------------------
@node    Database Connections
@chapter Procedures for managing connections

@deffn {Scheme Procedure} pg-connectdb connect-string
Open a connection to a database.  @var{connect-string} should be
a string consisting of zero or more space-separated @code{name=value} pairs.
If the value contains spaces it must be enclosed in single quotes and any
single quotes appearing in the value must be escaped using backslashes.
Backslashes appearing in the value must similarly be escaped.  Note that
if the @code{connect-string} is a Guile string literal then all the backslashes
will themselves require to be escaped a second time.
The @code{name} strings can be any of:

@table @code

@item host
The host-name or dotted-decimal IP address of the host on which the postmaster
is running.  If no @code{host=} sub-string is given then the host is assumed
to be the value of the environment variable @code{PGHOST} or the local
host if @code{PGHOST} is not defined.

@item port
The TCP or Unix socket on which the backend is listening.  If this is not
specified then the value of the @code{PGHOST} environment variable is used.
If that too is not defined then the default port 5432 is assumed.

@item options
A string containing the options to the backend server.  The options given
here are in addition to the options given by the environment variable
@code{PGOPTIONS}.  The options string should be a set of command line
switches as would be passed to the backend.  See the @code{postgres(1)}
man page for more details.

@item tty
A string defining the file or device on which error messages from the backend
are to be displayed.  If this is empty (@code{""}) then the environment variable
@code{PGTTY} is checked.  If the specified @code{tty} is a file then the file
will be readable only by the user the postmaster runs as (usually
@code{postgres}).  Similarly, if the specified @code{tty} is a device then it
must have permissions allowing the postmaster user to write to it.

@item dbname
The name of the database.  If no @code{dbname=} sub-string is given then the
database name is assumed to be that given by the value of the @code{PGDATABASE}
environment variable, or the @code{USER} environment variable if the
@code{PGDATABASE} environment variable is not defined.  If the @code{USER}
environment variable is not specified either then the value of the
@code{user} option is taken as the database name.

@item user
The login name of the user to authenticate.  If none is given then the
@code{PGUSER} environment variable is checked.  If that is not given then the
login of the user owning the process is used.

@item password
The password.  Whether or not this is used depends upon the contents of the
@code{pg_hba.conf} file.  See the @code{pg_hba.conf(5)} man page for details.

@item authtype
This must be set to @code{password} if password authentication is in use,
otherwise it must not be specified.

@end table

@heading Example
@lisp
(define (user-count host)
  (let* ((conn (pg-connectdb
                (string-append
                 "host=" host
                 " port=5432 dbname=template1")))
         (result (pg-exec conn "SELECT COUNT(*) FROM pg_user")))
    (and result
         (eq? 'PGRES_TUPLES_OK (pg-result-status result))
         (string->number (pg-getvalue result 0 0)))))
@end lisp
@end deffn

@deffn {Scheme Procedure} pg-reset conn
Reset the connection with the backend.  Equivalent to closing the connection
and re-opening it again with the same connect options as given to
@code{pg-connectdb}.  @var{conn} must be a valid @code{PG_CONN} object
returned by @code{pg-connectdb}.
@end deffn

@deffn {Scheme Procedure} pg-get-db conn
Return a string containing the name of the database to which @var{conn}
represents a connection.
@end deffn

@deffn {Scheme Procedure} pg-get-user conn
Return a string containing the user name used to authenticate
the connection @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-get-pass conn
Return a string containing the password used to authenticate the
connection @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-get-host conn
Return a string containing the name of the host to which
@var{conn} represents a connection.
@end deffn

@deffn {Scheme Procedure} pg-get-port conn
Return a string containing the port number to which @var{conn}
represents a connection.
@end deffn

@deffn {Scheme Procedure} pg-get-tty conn
Return a string containing the the name of the diagnostic tty for @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-get-options conn
Return a string containing the the options string for @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-backend-pid conn
Return an integer which is the the PID of the backend process for @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-get-client-data conn
Return the the client data associated with @var{conn}.
@end deffn

@deffn {Scheme Procedure} pg-set-client-data! conn data
Associate @var{data} with @var{conn}.

@heading Example
The following is a set of three procedures which implement a database
connection object that logs all the SQL statements it executes.

@lisp
(define (pg-connectdb-logged options)
  (let ((conn (pg-connectdb options)))
    (if conn
        (begin (pg-set-client-data! conn '())
               conn)
        #f)))

(define (pg-exec-logged conn sql)
  (pg-set-client-data! conn (append (pg-get-client-data conn)
                                    (list sql)))
  (pg-exec conn sql))

(define (pg-conn-log conn)
  (pg-get-client-data conn))
@end lisp
@end deffn

@c ---------------------------------------------------------------------------
@node    Retrieving Data
@chapter Procedures for Retrieving Data

@deffn {Scheme Procedure} pg-exec conn statement
Execute the SQL string @var{statement} on a given connection @var{conn}
returning either a @code{PG_RESULT} object containing a @code{pg-result-status}
or @code{#f} if an error occurred, in which case the error message can be
obtained using @code{pg-error-message}, passing it the @code{PG_CONN} object on
which the statement was attempted.  Note that the error message is available
only until the next call to @code{pg-exec} on this connection.

@heading Example
This example defines a procedure @code{pg-execute} which wraps @code{pg-exec}
so that a @code{misc-error} is thrown instead of returning false.  There are
numerous other examples of @code{pg-exec} calls throughout this chapter.

@lisp
(define (pg-execute conn sql)
  (let ((result (pg-exec conn sql)))
    (or result
        (error (pg-error-message conn)))))
@end lisp

@heading Notes
The entire result set is returned at once from a call to to @code{pg-exec}.
If a @code{SELECT} results in a very large number of tuples then this can be
a problem because it requires a large amount of memory.  In these cases it is
better to @code{DECLARE} a cursor over the @code{SELECT} and retrive small
numbers of rows at a time using @code{FETCH}.  These commands can only be
issued between @code{BEGIN TRANSACTION/END TRANSACTION} pairs.  See the
PostgreSQL @code{declare(l)} and @code{fetch(l)} man pages for more details.

@end deffn

@deffn {Scheme Procedure} pg-error-message conn
Return the most-recent error message that occurred on this connection,
or an empty string if the previous @code{pg-exec} succeeded.
@end deffn

@deffn {Scheme Procedure} pg-result-status result
Return the symbolic status of a @code{PG_RESULT} object returned by
@code{pg-exec}.  One of:

@table @code

@item PGRES_TUPLES_OK
The statement returned zero or more tuples.  The number of fields and tuples
returned can be determined from calls to @code{pg-nfields} and
@code{pg-ntuples} respectively.  The value of a given attribute (field)
of a given tuple can be determined by calling @code{pg-getvalue}.

@item PGRES_COMMAND_OK
The statement was a command (@code{INSERT}, @code{UPDATE}, @code{DELETE}
@code{CREATE TABLE}, @code{DROP TABLE} etc.),
which was executed without error.  The number of tuples affected by the
command can be determined by a call to @code{pg-cmdtuples}.

@item PGRES_EMPTY_QUERY
It is not known under which circumstances this result-status is returned.

@item PGRES_COPY_OUT
The statement was a @code{COPY <table> TO stdout}.  The data can be read using
@code{pg-getline}.

@item PGRES_COPY_IN
The statement was a @code{COPY <table> FROM stdin}.  The rows should be written
using @code{pg-putline}.

@item PGRES_BAD_RESPONSE
This occurs when the @code{libpq} interface receives an unexpected response
from the backend.  It indicates a problem with Postgres.

@item PGRES_NONFATAL_ERROR
It is not known under which circumstances this result-status is returned.

@item PGRES_FATAL_ERROR
The command was not executable for some reason.  This is the returned status
when a syntax error is detected in the command, for example.

@end table

@heading Example
This contrived example defines a procedure to insert records into a given
table, returning the number of tuples inserted (always one) or @code{#f} if an
error occurred.

@lisp
(define (pg-insert conn table record)
  (let ((result (pg-exec conn
                         (format #f "INSERT INTO ~A VALUES ~A"
                                 table record))))
    (and result
         (eq? 'PGRES_COMMAND_OK (pg-result-status result))
         (string->number (pg-cmdtuples result)))))
@end lisp

The procedure could be called as follows

@lisp
(pg-insert conn "people" "('Warbucks', 'Oliver')")
@end lisp
@end deffn

@deffn {Scheme Procedure} pg-get-connection result
Return the @code{PG_CONN} object representing the connection from which a
@var{result} was returned.
@end deffn

@deffn {Scheme Procedure} pg-binary-tuples? result
Return @code{#t} if @var{result} contains binary tuple data, @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} pg-fmod result field-number
Return the integer type-specific modification data for the given field
(@var{field-number}) of @var{result}.
@end deffn

@deffn {Scheme Procedure} pg-ntuples result
Return the number of tuples in @var{result}.
@end deffn

@deffn {Scheme Procedure} pg-nfields result
Return the number of fields in @var{result}.
@end deffn

@deffn {Scheme Procedure} pg-cmdtuples result
Return the number of tuples affected by a command.  This is a string
which is empty in the case of commands like @code{CREATE TABLE}, @code{GRANT},
@code{REVOKE} etc. which don't affect tuples.
@end deffn

@deffn {Scheme Procedure} pg-oid-status result
Return a string which contains the integer OID (greater than or equal to 0)
of the tuple inserted, or is empty if the command to which @var{result}
pertains was not @code{INSERT}.

@emph{NOTE:} This procedure is deprecated.  Use @code{pg-oid-value} instead.
@end deffn

@deffn {Scheme Procedure} pg-oid-value result
If the @var{result} is that of an SQL @code{INSERT} command, return the
integer OID of the inserted tuple, otherwise return @code{#f}.
@end deffn

@deffn {Scheme Procedure} pg-fname result field-number
Return a string containing the canonical lower-case name of the field
@var{field-number} in @var{result}.  SQL variables and field names are not
case-sensitive.
@end deffn

@deffn {Scheme Procedure} pg-fnumber result field-name
Return the integer field-number corresponding to @var{field-name} if this
exists in @var{result}, or @code{-1} otherwise.
@end deffn

@deffn {Scheme Procedure} pg-getvalue result tuple field-number
Return a string containing the value of the attribute @var{field-number},
tuple @var{tuple} of @var{result}.  It is up to the caller to
convert this to the required type.

This example defines a procedure @code{pg-gettuple} which returns a given
tuple as an alist, keyed on the field name.  It's not an especially efficient
procedure because it constructs the list of field-names afresh each time it's
called.

@lisp
(define (pg-fnames result)
  (let ((nfields (pg-nfields result)))
    (define (iter i)
      (if (= i nfields) '()
          (cons (pg-fname result i) (iter (+ i 1)))))
    (iter 0)))

(define (pg-getvalues result tuple)
  (let ((nfields (pg-nfields result)))
    (define (iter i)
      (if (= i nfields) '()
          (cons (pg-getvalue result tuple i) (iter (+ i 1)))))
    (iter 0)))

(define (pg-gettuple result tuple)
  (map (lambda (n v) (cons (string->symbol n) v))
       (pg-fnames result)
       (pg-getvalues result tuple)))
@end lisp

Field values can be extracted from the tuple using @code{assq-ref}, eg:

@lisp
(define tup (pg-gettuple result 0))
(assq-ref tup 'firstname)
@end lisp

Using this procedure we can define a version of @code{for-each} which
iterates through the tuples returned from a given @code{SELECT} query:

@lisp
(define (pg-for-each proc result)
  (let ((ntuples (pg-ntuples result)))
    (define (iter i)
      (cond ((= i ntuples) ntuples)
            (else (proc (pg-gettuple result i))
                  (iter (+ i 1)))))
    (iter 0)))
@end lisp

This implementation of @code{pg-for-each} inherits inefficiency from the
@code{pg-gettuple} procedure.

@heading Notes
The @code{pg-getvalue} procedure throws
@code{out-of-range} errors if either the @code{tuple} or @code{field-number}
arguments are out of range.
@end deffn

@deffn {Scheme Procedure} pg-getisnull result tuple field-number
Return @code{#t} if the attribute is @code{NULL}, @code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} pg-ftype result field-number
Return the PostgreSQL internal integer representation of the type of
the given attribute.  The integer is actually an OID (object ID) which
can be used as the primary key to reference a tuple from the system table
@code{pg_type}.  A @code{misc-error} is thrown if the @code{field-number}
is not valid for the given @code{result}.
@heading Example
This defines a procedure @code{pg-ftype-name} which returns the type
name of a given attribute in a string.

A more efficient implementation would be to define
a type of connection which, when opened, issued the query to retrieve the
@code{pg_type} system table once.  An alist for looking up type names could
then be associated with each connection using @code{pg-set-client-data!}.

@lisp
(define (pg-ftype-name result fnum)
  (let ((result (pg-exec
                 (pg-get-connection result)
                 (format #f "SELECT typname FROM pg_type WHERE oid = ~A"
                         (pg-ftype result fnum)))))
    (or (and result
             (eq? 'PGRES_TUPLES_OK (pg-result-status result))
             (> (pg-ntuples result) 0)
             (pg-getvalue result 0 0))
        "")))
@end lisp
@end deffn

@deffn {Scheme Procedure} pg-fsize result field-number
Return the size of a given attribute in bytes, or -1 if the field is
variable-length.
@end deffn

@deffn {Scheme Procedure} pg-getlength result tuple field-number
The size of the datum in bytes.
@end deffn

@c ---------------------------------------------------------------------------
@node    Writing/Reading Data
@chapter Procedures for Copying Data

@deffn {Scheme Procedure} pg-getline conn
Read a line from a connection on which a @code{COPY <table> TO STDOUT} has
been issued.
Return a string from the connection.  If the returned string consists of only
a backslash followed by a full stop, then the results
from the @code{COPY} command have all been read and @code{pg-endcopy} should
be called to resynchronise the connection before any further calls to
@code{pg-exec} on this connection.
@heading Example
This example defines a procedure @code{pg-copy-to-port} which can be used
to retrieve the results of a @code{COPY <table> TO STDOUT} command.

@lisp
(define (pg-copy-to-port conn port)
  (define (iter)
    (let ((line (pg-getline conn)))
      (if (string=? line "\\.")
          (pg-endcopy conn)
          (begin (write-line line port)
                 (iter)))))
  (iter))
@end lisp
@heading Notes
It is an error to call @code{pg-getline} on a connection without first
executing a @code{COPY <table> TO STDOUT} command on that connection.
It is also an error to call @code{pg-getline} after a terminating line has
been received, without an intervening @code{COPY} command being issued on
that connection.
@end deffn

@deffn {Scheme Procedure} pg-putline conn string
Write a line to the connection on which a @code{COPY <table> FROM STDIN} has
been issued.  The lines written should include the final newline characters.

The last line should be a backslash, followed by a full-stop.  After this,
the @code{pg-endcopy} procedure should be called for this connection before
any further @code{pg-exec} call is made.
The return value is undefined.

@heading Example
This example defines a procedure @code{pg-copy-from-port} which can be used
to supply data to a @code{COPY <table> TO STDIN} command.

@lisp
(define (pg-copy-from-port conn port)
  (define (iter)
    (let ((line (read-line port)))
      (if (eof-object? line)
          (begin (pg-putline conn "\\.\n")
                 (pg-endcopy conn))
          (begin (pg-putline conn line)
                 (pg-putline conn "\n")
                 (if (string=? line "\\.")
                     (pg-endcopy conn)
                     (iter))))))
  (iter))
@end lisp
@end deffn

@deffn {Scheme Procedure} pg-endcopy conn
Resynchronize with the backend process.  This procedure must be called after
the last line of a table has been transferred using @code{pg-getline} or
Returns an integer: zero if successful, non-zero otherwise.
@end deffn

@c ---------------------------------------------------------------------------
@node    Large Objects
@chapter Procedures for Managing Large Objects

@heading Note
All of the operations on large objects must be carried out inside a
@code{BEGIN TRANSACTION/END TRANSACTION} pair.  Failure to do this
will result in a loss of synchronisation between the backend and the
@code{libpq} library, resulting in an unusable connection to the
database, and possible corruption of data.

@deffn {Scheme Procedure} pg-lo-creat conn modes
Create a new large object and open a port over it for reading and/or writing.
@var{modes} is a string describing the mode in which the port is to be opened.
The mode string must include one of @code{r} for reading, @code{w} for writing
or @code{a} for append (but since the object is empty to start with this is
the same as @code{w}.)  The return value is a large object port which can be
used to read or write data to/from the object, or @code{#f} on failure in
which case @code{pg-error-message} from the connection should give some idea
of what happened.

In addition to returning @code{#f} on failure this procedure throws a
@code{misc-error} if the @code{modes} string is invalid.
@end deffn

@deffn {Scheme Procedure} pg-lo-open conn oid modes
Open a port over an existing large object.  The port can be used to read or
write data from/to the object.
@var{oid} should be an integer identifier representing the large object.
@var{modes} must be a string describing the mode in which the port is to be
opened.  The mode
string must include one of @code{r} for reading, @code{w} for writing,
@code{a} for append or @code{+} with any of the above indicating both
reading and writing/appending.  @code{A} is equivalent to opening the port
for writing and immediately doing a @code{(pg-lo-seek)} to the end.
The return value is either an open large object port
or @code{#f} on failure in which case @code{pg-error-message}
from the connection should give some idea of what happened.
@heading Notes
This procedure throws a @code{misc-error} exception if the @code{modes}
string is invalid.
@end deffn

@deffn {Scheme Procedure} pg-lo-unlink conn oid
Delete the large object identified by @var{oid}.
Return @code{#t} if the object was successfully deleted, @code{#f} otherwise,
in which case @code{pg-error-message} applied to @code{conn} should give an
idea of what went wrong.
@end deffn

@deffn {Scheme Procedure} pg-lo-get-connection port
Return the connection associated with a given large object port.
@var{Port} must be a large object port returned from @code{pg-lo-creat}
or @code{pg-lo-open}.
@end deffn

@deffn {Scheme Procedure} pg-lo-get-oid port
Return the integer identifier of the object to which a given port applies.
@var{Port} must be a large object port returned from @code{pg-lo-creat}
or @code{pg-lo-open}.
@end deffn

@deffn {Scheme Procedure} pg-lo-tell port
Return the position of the file pointer for the given large object port.
@var{Port} must be a large object port returned from @code{pg-lo-creat}
or @code{pg-lo-open}.
The return value is either an integer greater than or equal to zero
or @code{#f} if an error occurred.  In the latter case
@code{pg-error-message} applied to @code{conn}
should explain what went wrong.
@end deffn

@deffn {Scheme Procedure} pg-lo-seek port where whence
Set the position of the next read or write to/from the given large object
port.  @var{Port} must be a large object port returned from @code{pg-lo-creat}
or @code{pg-lo-open}.  @var{Where} is the position to set the pointer.
@var{Whence} must be one of

@table @code

@item SEEK_SET
Relative to the beginning of the file.

@item SEEK_CUR
Relative to the current position.

@item SEEK_END
Relative to the end of the file.

@end table
The return value is an integer which is the new position relative to the
beginning of the object, or a number less than zero if an error occurred.
@heading Notes
It is possible to seek beyond the end of file opened only for reading.  In
which case subsequent reads of the port will return an EOF object.

@end deffn

@deffn {Scheme Procedure} pg-lo-read size number port
Read @var{number} objects each of length @var{size} from @var{port}.
Return a string containing the data read from the port or @code{#f} if an error
occurred.
@end deffn

@deffn {Scheme Procedure} pg-lo-import conn filename
Create a new large object and loads it with the contents of the specified
file.  @var{Filename} must be a string containing the name of the file to be
loaded into the new object.  Return the integer identifier (OID) of the newly
created large object, or @code{#f} if an error occurred, in which case
@code{pg-error-message} should be consulted to determine the failure.
@end deffn

@deffn {Scheme Procedure} pg-lo-export conn oid filename
Write the contents of a given large object to a file.
@var{Oid} is the integer identifying the large object to be exported and
@var{filename} the name of the file to contain the object data.
Return @code{#t} on success, @code{#f} otherwise, in which case
@code{pg-error-message} may offer an explanation of the failure.
@end deffn

@c ---------------------------------------------------------------------------
@node    Miscellaneous
@chapter Miscellaneous Procedures

@deffn {Scheme Procedure} pg-guile-pg-loaded
Return @code{#t} indicating that the binary part of @code{guile-pg} is loaded.
Thus to test if @code{guile-pg} is loaded, use
@lisp
(defined? 'pg-guile-pg-loaded)
@end lisp

@heading Note
This procedure is guaranteed to be present in all future versions of
@code{guile-pg}.
@end deffn

@deffn {Scheme Procedure} pg-guile-pg-version
Return a string giving the version of @code{guile-pg}.  The string is
always of the form "M.m" giving major and minor versions.
@end deffn

@deffn {Scheme Procedure} pg-guile-pg-module-version
Return a string giving the version of the scheme module @code{postgres.scm}.
The string is always of the form "M.m" giving major and minor versions.
Unless something is wrong with the installation, this should be the same as
@code{pg-guile-pg-version}.
@end deffn

@deffn {Scheme Procedure} pg-guile-pg-module-config-stamp
Return a string containing the date and time at which @code{guile-pg}
was configured (this is probably the build time.)
@end deffn

@deffn {Scheme Procedure} pg-trace conn port
Start outputting low-level trace information on the connection @var{conn} to
@var{port}, which must have been opened for writing.  This trace
is more useful for debugging Postgres than it is for debugging applications.
The return value is unspecified.

@heading Example
This example defines a pair of procedures @code{pg-trace-on} and
@code{pg-trace-off} which implement a higher-level trace procedure which
opens the required file and starts/stops the trace.

@lisp
(define (pg-trace-on conn filename)
  (let ((port (open-file filename "w")))
    (pg-set-client-data! conn port)
    (pg-trace conn port)))

(define (pg-trace-off conn)
  (let ((port (pg-get-client-data conn)))
    (and port
         (begin
           (close-port port)
           (pg-untrace conn)))))
@end lisp
@end deffn

@deffn {Scheme Procedure} pg-untrace conn
Stop tracing on a given connection.  The return value is unspecified.
@end deffn

@c ---------------------------------------------------------------------------
@node    Types Conversion
@chapter Types Conversion

Normally, the result of a @code{pg-exec} query is an object from which Scheme
strings can be extracted to represent the datum from a particular tuple/field
pair, using @code{pg-getvalue}.  If this string is sufficient for your needs,
you can skip this chapter, which describes how to use the PostgreSQL-to-Scheme
(and back) type conversion support installed with Guile-PG, including how to
register new types/converters.

To get started, load the @code{postgres-types} module:
@example
(use-modules (database postgres-types))
@end example

Here is a snapshot of the commentary (in lieu of better documentation, while
we get our doc-harvesting methodology up to speed):

@example
This module provides the procs:
 (dbcoltypes) => list of names
 (dbcoltype-lookup NAME) => tobj
 (dbcoltype:name TOBJ) => symbol
 (dbcoltype:stringifier TOBJ) => proc
 (dbcoltype:objectifier TOBJ) => proc
 (dbcoltype:default) => string
 (define-db-col-type NAME DEFAULT STRINGIFY OBJECTIFY)
 (define-db-col-type-array-variant COMPOSED SIMPLE [STRINGIFY [OBJECTIFY]])

NAME, COMPOSED and SIMPLE are symbols naming a type.  COMPOSED is
conventionally formed by appending square-bracket paris to SIMPLE.  For
example, we can declare a two-dimensional array type of text elements:

 (define-db-col-type-array-variant 'text[][] 'text ...)

STRINGIFY is a procedure that takes a Scheme object and returns a string,
suitable for sending to PostgreSQL.  OBJECTIFY does the opposite: it takes
a string from PostgreSQL and returns a Scheme object.

DEFAULT is a string.  TOBJ is a "type object" which should be considered
opaque (use the dbcoltype:foo procs to access the components).
@end example

To see what types are already defined, use the @code{dbcoltypes} procedure.

@c + @twerpdoc (dbcoltypes)

Here is a simple example that uses @code{dbcoltype-lookup} and
@code{dbcoltype:objectifier} to convert a @code{text[][]} value
into a nested list:

@lisp
(let ((raw (pg-getvalue result 0 0))
      (conv (dbcoltype:objectifier (dbcoltype-lookup 'text[][]))))
  (write-line raw)
  (write-line (conv raw)))
@print{} @{@{a,b@},@{c,d@}@}
@print{} (("a" "b") ("c" "d"))
@end lisp

Note that even though the type is an "array", as implied by the square
brackets, the result is a list.  This is mostly due to a limitation in
PostgreSQL: dimensionality is not stored for array types, so the conversion
cannot be done in a random-access manner.  Perhaps this will change in the
future.

@section Defining New Types

To define a new non-array type means associating with the type name a
procedure for converting from a PostgreSQL string representation to a Scheme
object (the @dfn{objectifier}), a procedure to do the conversion in the
opposite direction (the @dfn{stringifier}), and a default string to use if
none is specified (for example, during an @code{INSERT} operation).  For this,
use the @code{define-db-col-type} procedure.

@c + @twerpdoc (define-db-col-type)

To express conversion of arrays (no matter the dimensionality) of non-array
types, use the @code{define-db-col-type-array-variant} procedure.

@c + @twerpdoc (define-db-col-type-array-variant)

@c ---------------------------------------------------------------------------
@node    Single-Table Abstraction
@chapter Single-Table Abstraction

For some database usages, it is convenient to focus on a single table, adding
rows to it or drawing queries from it exclusively of any other tables in the
database.  This chapter describes Guile-PG facilities for this kind of use.

To get started, load the @code{postgres-table} module:
@example
(use-modules (database postgres-table))
@end example

Here is a snapshot of the commentary (in lieu of better documentation, while
we get our doc-harvesting methodology up to speed):

@example
This module exports these procedures:
 (sql-pre string)
 (tuples-result->table res)
 (where-clausifier string)
 (pgtable-manager db-name table-name defs)
 (def:col-name def)
 (def:type-name def)
 (def:type-options def)
@end example

Basically, the @code{pgtable-manager} procedure encapsulates specification,
query and mutation (including create/delete) of a PostgreSQL table.  The
@var{defs} are a list of the columns, each element having the form:

@example
        (NAME TYPE [OPTIONS...])
@end example

@var{name} and @var{type} are symbols specifying the name and type of the
column, respectively (@pxref{Types Conversion}).  @var{options} are strings
passed directly to PostgreSQL as part of a @code{CREATE TABLE} command.  For
example, the status output of the rsync(1) program can be specified by the
form:

@example
(define rsync-defs
        '((time            timestamp)
          (error_condition text)
          (files           text[])
          (wrote           int4)          ; bytes
          (read            text[][])
          (rate            float4)
          (total           int4)          ; bytes
          (speedup         float4)
          (etc             int4[])))
@end example

Note that there are no options in this example.

@c + @twerpdoc (pgtable-manager)

The other procedures are useful for succintly codifying queries, and
translating the result en mass to Scheme objects.

@c + @twerpdoc (tuples-result->table)

@c + @twerpdoc (sql-pre)

@c + @twerpdoc (where-clausifier)

@example
(define m (pgtable-manager "ttn" "guile_pg_demo"
                           '((i          serial)
                             (date       timestamp)
                             (amount     float4)
                             (catcode    text)
                             (details    text[]))))

((m 'create))
@result{} #<PG-RESULT:1:PGRES_COMMAND_OK:0:0>

(define add (m 'insert-col-values))
(define sel (m 'select))

(add '(date amount) (current-time) 1.98)
@result{} #<PG-RESULT:2:PGRES_COMMAND_OK:0:0>

(add '(date amount) (current-time) 2.98)
@result{} #<PG-RESULT:3:PGRES_COMMAND_OK:0:0>

(define result (sel "count(*)" (where-clausifier "amount < 2.00")))

result
@result{} #<PG-RESULT:4:PGRES_TUPLES_OK:1:1>

(tuples-result->table result)
@result{} #2(("1"))

((m 'drop))
@result{} (#<PG-RESULT:5:PGRES_COMMAND_OK:0:0> #<PG-RESULT:6:PGRES_COMMAND_OK:0:0>)
@end example

Two things to note in this example: (1) Both @code{create} and @code{drop}
invocations evaluate the operating thunk directly (double parentheses); and
(2) The drop returns a list of result values to accomodate the possibility
(shown here) of a @code{serial} column type, which requires an additional drop
of the associated PostgreSQL @dfn{sequence} used to implement the expected
serial behavior.  (As of PostgreSQL 7.x, the sequence name is constructed like
so: TABLENAME_COLNAME_seq.  For more info, see the PostgreSQL User Guide,
Chapter 3: Data Types.

@c ---------------------------------------------------------------------------
@c + @node       Concept Index
@c + @unnumbered Concept Index
@c +
@c + @printindex cp

@c ---------------------------------------------------------------------------
@node       Procedure Index
@unnumbered Procedure Index

@printindex fn

@contents

@bye
