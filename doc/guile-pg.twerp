\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename guile-pg.info
@settitle @code{Guile-pg} Command Reference
@paragraphindent 0
@c %**end of header
@code{}
@setchapternewpage odd

@dircategory Guile modules
@direntry
* Guile-pg: (guile-pg).           Access to PostgreSQL databases from Guile.
@end direntry

@ifinfo
This file is the Guile-pg Command Reference

Copyright @copyright{} 1998, 2002, 2003, 2004 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and
print the results, provided the printed document carries a copying
permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{@code{Guile-pg} Command Reference}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998, 2002, 2003, 2004 Free Software Foundation, Inc.

     Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice are
preserved on all copies.

     Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled ``Copying'' and ``GNU General Public
License'' are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@c ---------------------------------------------------------------------------
@node Top
@top  Guile-pg

@code{Guile-pg} is a Guile module providing a set of procedures to allow
access to the PostgreSQL RDBMS from Scheme programs.

Guile is an interpreter for the Scheme programming language: a dialect of
Lisp.  PostgreSQL is a free SQL database management system.
@code{Guile-pg} is intended as but one of the low-level drivers for the
forthcoming Guile database module which will provide a portable interface
to many different SQL database servers.  In the mean-time
it will still be a useful module for those who want just a low-level
interface to PostgreSQL.

The @code{Guile-pg} procedures have an almost one-one correspondence
with the PostgreSQL @code{libpq} C library interface so those familiar with
the @code{libpq} library and other similar interfaces like Edmund Mergl's
@code{Pg} Perl module will find it familiar.

@code{Guile-pg} is based on Russ McManus's ``Sybase glue'' code.

@menu
* Legalities::                  Your rights and freedoms.
* Quick Start::                 Overview and brief examples.

* Database Connections::        Groundwork for database interaction.
* Retrieving Data::             Making queries and accessing results.
* Writing/Reading Data::        Bulk data movement and I/O.
* Large Objects::               Large-Object support.
* Miscellaneous::               Everything else starting with "pg-".

* Types Conversion::            Module: (database postgres-types).
* Column Definitions::          Module: (database postgres-col-defs).
* Result Transforms::           Module: (database postgres-resx).
* Single-Table Abstraction::    Module: (database postgres-table).
* Introspection::               Module: (database postgres-meta).

* Procedure Index::
@end menu

@c ---------------------------------------------------------------------------
@node    Legalities
@chapter Legalities

Guile-PG is released under the GNU General Public License; a copy of this
document is included in the distribution as file @file{COPYING}.

Please support free software by visiting @url{http://www.gnu.org} and
contributing fixes and other improvements to guile-pg.

@c ---------------------------------------------------------------------------
@node    Quick Start
@chapter Quick Start

To access a PostgreSQL database from Guile, first load the @code{postgres}
database module. This is done using the @code{use-modules} syntax:
@lisp
(use-modules (database postgres))
@end lisp

The next step is to make a connection to the database using the
@code{pg-connectdb} procedure. Then, having created a valid connection to a
database server, we can use the @code{pg-exec} procedure to execute
queries and the other @code{pg-} procedures to retrieve the results of the
queries.

The following Guile session opens a connection and executes an
SQL statement on the @code{test} database on the default host (either
@code{localhost} or the host specified in the @code{PGHOST} environment
variable.)

@cartouche
@example
guile> (use-modules (database postgres))
guile> (define test (pg-connectdb "dbname=test"))
guile> test
#<PG-CONN:1:test::5432:>
guile> (define result (pg-exec test "SELECT * FROM PEOPLE"))
guile> result
#<PG-RESULT:1:PGRES_TUPLES_OK:3:5>
@end example
@end cartouche

The @code{test} object is a @code{PG-CONN} type representing the database
connection.  Displaying the @code{PG-CONN} object shows that the serial number
of the connection is 1, that the database name is @code{test} on the default
host (the hostname field is empty) on port number 5432 and that the default
options were passed to the backend.  This object is passed to @code{pg-exec}
which returns a @code{PG-RESULT} object representing the result of the SQL
statement executed on the server.  In this case, displaying the @code{PG-RESULT}
object shows us that the serial number of the result is 2, that the return code
from the database was @code{PGRES_TUPLES_OK} and that we have received 3 tuples
with 5 fields.

Having obtained a result object from the database we can find out how
many rows and how many columns are in the result.  We can also find out the
names of the columns:

@cartouche
@example
guile> (pg-ntuples result)
3
guile> (pg-nfields result)
5
guile> (pg-fname result 0)
"surname"
guile> (pg-fname result 1)
"firstname"
@end example
@end cartouche

To retrieve the data from the result we use the @code{pg-getvalue} procedure.
This takes a result object along with the row and column numbers and returns a
string containing that value.  @code{pg-getvalue} always returns a string: it
is up to the caller to convert this to whatever type they require.

@cartouche
@example
guile> (pg-getvalue result 0 0)
"Bitdiddle"
guile> (pg-getvalue result 0 1)
"Ben"
guile> (pg-getvalue result 1 0)
"Ator"
guile> (pg-getvalue result 1 1)
"Eva Lu"
@end example
@end cartouche

@code{Guile-pg} connections are closed when Guile's garbage collector
collects the discarded object.  This only happens when the connection itself
and all of the results of @code{pg-exec} are unreachable.  So to close the
connection we just rebind the results from that connection and the connection
symbol itself:

@cartouche
@example
guile> (define result '())
guile> (define test '())
@end example
@end cartouche

Typically though the result and connection variables will be @code{let}
bindings so the connection will usually be closed soon after the body of the
@code{let} returns.

@c ---------------------------------------------------------------------------
@node    Database Connections
@chapter Procedures for managing connections

All sessions with a PostgreSQL database require a connection to be opened with
@code{pg-connectdb}.

@twerpdoc (pg-connection?)
@twerpdoc (pg-connectdb)

@heading Example
@lisp
(define (user-count host tcp-port)
  (let* ((conn (pg-connectdb
                (format #f "host=~A port=~A dbname=template1"
                        host tcp-port)))
         (result (pg-exec conn "SELECT COUNT(*) FROM pg_user")))
    (and result
         (eq? 'PGRES_TUPLES_OK (pg-result-status result))
         (string->number (pg-getvalue result 0 0)))))
@end lisp

Notices are messages sent from the back- to the front-end, sometimes prefixed
with the word @code{NOTICE}, and always followed by a trailing newline.  By
default, they are sent to the current output port.

@twerpdoc (pg-set-notice-out!)

@twerpdoc (pg-reset)

@twerpdoc (pg-get-db)

@twerpdoc (pg-get-user)

@twerpdoc (pg-get-pass)

@twerpdoc (pg-get-host)

@twerpdoc (pg-get-port)

@twerpdoc (pg-get-tty)

@twerpdoc (pg-get-options)

@twerpdoc (pg-backend-pid)

@section Client Data

The libpq interface upon which Guile-PG is built supports assocation of
arbitrary data with a connection.  You can use these @dfn{client data}
procedures or the more general @dfn{object property} procedures in Guile.

@twerpdoc (pg-get-client-data)

@twerpdoc (pg-set-client-data!)

@heading Example
The following is a set of three procedures which implement a database
connection object that logs all the SQL statements it executes.

@lisp
(define (pg-connectdb/logged options)
  (let ((conn (pg-connectdb options)))
    (and conn
         (begin (pg-set-client-data! conn '())
                conn))))

(define (pg-exec/logged conn sql)
  (pg-set-client-data! conn (append (pg-get-client-data conn)
                                    (list sql)))
  (pg-exec conn sql))

(define (conn-log conn)
  (pg-get-client-data conn))
@end lisp

Here are implementations using object properties, using the symbol @code{log}
as the key.

@lisp
(define put set-object-property!)
(define get object-property)

(define (pg-connectdb/logged options)
  (let ((conn (pg-connectdb options)))
    (put conn 'log '())
    conn))

(define (pg-exec/logged conn sql)
  (put conn 'log (append (get conn 'log)
                         (list sql)))
  (pg-exec conn sql))

(define (conn-log conn)
  (get conn 'log))
@end lisp

@section Asynchronous Notifications

The PostgreSQL backend supports @dfn{asynchronous notifications}
with the commands @code{LISTEN} and @code{NOTIFY}.  You can use
@code{pg-notifies} to query the pending notifications queue.

@twerpdoc (pg-notifies)

@c ---------------------------------------------------------------------------
@node    Retrieving Data
@chapter Procedures for Retrieving Data

To get an answer you have to ask a question, i.e., send either a command or a
query to the connection using @code{pg-exec}.  The return value's type can be
tested with @code{pg-result?}.

@twerpdoc (pg-exec)

@twerpdoc (pg-result?)

@heading Example
This example defines a procedure @code{pg-exec/no-false} which wraps
@code{pg-exec} so that a @code{misc-error} is thrown instead of returning
false.  There are numerous other examples of @code{pg-exec} calls throughout
this chapter.

@lisp
(define (pg-exec/no-false conn sql)
  (or (pg-exec conn sql)
      (error (pg-error-message conn))))
@end lisp

@heading Notes
The entire result set is returned at once from a call to to @code{pg-exec}.
If a @code{SELECT} results in a very large number of tuples then this can be
a problem because it requires a large amount of memory.  In these cases it is
better to @code{DECLARE} a cursor over the @code{SELECT} and retrive small
numbers of rows at a time using @code{FETCH}.  These commands can only be
issued between @code{BEGIN TRANSACTION/END TRANSACTION} pairs.  See the
PostgreSQL @code{declare(l)} and @code{fetch(l)} man pages for more details.

@twerpdoc (pg-error-message)

@twerpdoc (pg-result-status)

@heading Result Status Values
@table @code

@item PGRES_TUPLES_OK
The statement returned zero or more tuples.  The number of fields and tuples
returned can be determined from calls to @code{pg-nfields} and
@code{pg-ntuples} respectively.  The value of a given attribute (field)
of a given tuple can be determined by calling @code{pg-getvalue}.

@item PGRES_COMMAND_OK
The statement was a command (@code{INSERT}, @code{UPDATE}, @code{DELETE}
@code{CREATE TABLE}, @code{DROP TABLE} etc.),
which was executed without error.  The number of tuples affected by the
command can be determined by a call to @code{pg-cmdtuples}.

@item PGRES_EMPTY_QUERY
It is not known under which circumstances this result-status is returned.

@item PGRES_COPY_OUT
The statement was a @code{COPY <table> TO stdout}.  The data can be read using
@code{pg-getline}.

@item PGRES_COPY_IN
The statement was a @code{COPY <table> FROM stdin}.  The rows should be written
using @code{pg-putline}.

@item PGRES_BAD_RESPONSE
This occurs when the @code{libpq} interface receives an unexpected response
from the backend.  It indicates a problem with Postgres.

@item PGRES_NONFATAL_ERROR
It is not known under which circumstances this result-status is returned.

@item PGRES_FATAL_ERROR
The command was not executable for some reason.  This is the returned status
when a syntax error is detected in the command, for example.

@end table

@heading Example
This contrived example defines a procedure to insert a record into a given
table, returning the number of tuples inserted (always one) or @code{#f} if an
error occurred.

@lisp
(define (insert-one-record conn table record)
  (let ((result (pg-exec conn
                         (format #f "INSERT INTO ~A VALUES ~A"
                                 table record))))
    (and result
         (eq? 'PGRES_COMMAND_OK (pg-result-status result))
         (string->number (pg-cmdtuples result)))))
@end lisp

The procedure could be called as follows

@lisp
(insert-one-record conn "people" "('Warbucks', 'Oliver')")
@end lisp

@twerpdoc (pg-get-connection)

@twerpdoc (pg-binary-tuples?)

@twerpdoc (pg-fmod)

@twerpdoc (pg-ntuples)

@twerpdoc (pg-nfields)

@twerpdoc (pg-cmdtuples)

@twerpdoc (pg-oid-status)

@b{NOTE}: @code{pg-oid-status} is deprecated.  Use @code{pg-oid-value} instead.

@twerpdoc (pg-oid-value)

@twerpdoc (pg-fname)

@twerpdoc (pg-fnumber)

@twerpdoc (pg-getvalue)

This example defines a procedure @code{tuple->alist} which returns a given
tuple as an alist, keyed on the field name.  It's not an especially efficient
procedure because it constructs the list of field-names afresh each time it's
called.

@lisp
(define (field-names result)
  (map (lambda (field)
         (pg-fname result field))
       (iota (pg-nfields result))))

(define (get-values result tuple)
  (map (lambda (field)
         (pg-getvalue result tuple field))
       (iota (pg-nfields result))))

(define (tuple->alist result tuple)
  (map (lambda (n v) (cons (string->symbol n) v))
       (field-names result)
       (get-values result tuple)))
@end lisp

Field values can be extracted from the tuple using @code{assq-ref}, eg:

@lisp
(assq-ref (tuple->alist result 0) 'firstname)
@end lisp

Using this procedure we can define a version of @code{for-each} which
iterates through the tuples returned from a given @code{SELECT} query:

@lisp
(define (for-each-tuple proc result)
  (let ((end (pg-ntuples result)))
    (do ((tuple 0 (1+ tuple)))
        ((= tuple end))
      (proc (tuple->alist result tuple)))))
@end lisp

This implementation of @code{for-each-tuple} inherits inefficiency from the
@code{tuple->alist} procedure.

@heading Notes
The @code{pg-getvalue} procedure throws
@code{out-of-range} errors if either the @code{tuple} or @code{field-number}
arguments are out of range.

@twerpdoc (pg-getisnull)

@twerpdoc (pg-ftype)

@heading Example
This defines a procedure @code{field-type-name} which returns the type
name of a given attribute in a string.

A more efficient implementation would be to define
a type of connection which, when opened, issued the query to retrieve the
@code{pg_type} system table once.  An alist for looking up type names could
then be associated with each connection using @code{pg-set-client-data!}.

@lisp
(define (field-type-name result fnum)
  (let ((result (pg-exec
                 (pg-get-connection result)
                 (format #f "SELECT typname FROM pg_type WHERE oid = ~A"
                         (pg-ftype result fnum)))))
    (or (and result
             (eq? 'PGRES_TUPLES_OK (pg-result-status result))
             (< 0 (pg-ntuples result))
             (pg-getvalue result 0 0))
        "")))
@end lisp

@twerpdoc (pg-fsize)

@twerpdoc (pg-getlength)

@c ---------------------------------------------------------------------------
@node    Writing/Reading Data
@chapter Procedures for Copying Data

@twerpdoc (pg-getline)

@heading Example
This example defines a procedure @code{copy-to-port} which can be used
to retrieve the results of a @code{COPY <table> TO STDOUT} command.

@lisp
(define (copy-to-port conn port)
  (let loop ((line (pg-getline conn)))
    (if (string=? line "\\.")
        (pg-endcopy conn)
        (begin (write-line line port)
               (loop (pg-getline conn))))))
@end lisp
@heading Notes
It is an error to call @code{pg-getline} on a connection without first
executing a @code{COPY <table> TO STDOUT} command on that connection.
It is also an error to call @code{pg-getline} after a terminating line has
been received, without an intervening @code{COPY} command being issued on
that connection.

@twerpdoc (pg-putline)

@heading Example
This example defines a procedure @code{copy-from-port} which can be used
to supply data to a @code{COPY <table> TO STDIN} command.

@lisp
(define (copy-from-port conn port)
  (let loop ((line (read-line port)))
    (if (eof-object? line)
        (begin (pg-putline conn "\\.\n")
               (pg-endcopy conn))
        (begin (pg-putline conn line)
               (pg-putline conn "\n")
               (if (string=? line "\\.")
                   (pg-endcopy conn)
                   (loop (read-line port)))))))
@end lisp

@twerpdoc (pg-endcopy)

Although not readily apparent, another form of data copying is @dfn{formatted
output}, which is supported by Guile-PG via the @code{pg-print} procedure and
the accompanying @code{pg-make-print-options}.  Together these loosely mimic
the @code{PQprint} functionality provided by libpq.

@twerpdoc (pg-make-print-options)

@twerpdoc (pg-print)

@c ---------------------------------------------------------------------------
@node    Large Objects
@chapter Procedures for Managing Large Objects

@heading Note
All of the operations on large objects must be carried out inside a
@code{BEGIN TRANSACTION/END TRANSACTION} pair.  Failure to do this
will result in a loss of synchronisation between the backend and the
@code{libpq} library, resulting in an unusable connection to the
database, and possible corruption of data.

@twerpdoc (pg-lo-creat)

@twerpdoc (pg-lo-open)

@twerpdoc (pg-lo-unlink)

@twerpdoc (pg-lo-get-connection)

@twerpdoc (pg-lo-get-oid)

@twerpdoc (pg-lo-tell)

@twerpdoc (pg-lo-seek)

@heading Note
It is possible to seek beyond the end of file opened only for reading, in
which case subsequent reads of the port will return an EOF object.

@twerpdoc (pg-lo-read)

@twerpdoc (pg-lo-import)

@twerpdoc (pg-lo-export)

@c ---------------------------------------------------------------------------
@node    Miscellaneous
@chapter Miscellaneous Procedures

This chapter describes procedures whose name begins with "pg-" that do not
necessarily belong in the other chapters.

@c the first two "leave in for now" is due to "guile-tools c2doc" mishandling
@c an ARGLIST of '(void)', creating something like: (pg-guile-pg-loaded())
@c in the .doc file.  the latter two are because scm/postgres.scm.in is not
@c scanned at this time.

@c leave in for now --ttn
@c + @twerpdoc (pg-guile-pg-loaded)
@deffn {Scheme Procedure} pg-guile-pg-loaded
Return @code{#t} indicating that the binary part of
@code{guile-pg} is loaded.  Thus, to test if @code{guile-pg}
is loaded, use:
@lisp
(defined? 'pg-guile-pg-loaded)
@end lisp
NOTE: This procedure is guaranteed to be present in all future versions of
Guile-pg.
@end deffn

@c leave in for now --ttn
@c + @twerpdoc (pg-guile-pg-version)
@deffn {Scheme Procedure} pg-guile-pg-version
Return a string giving the version of @code{guile-pg}.
The form is "M.m" giving major and minor versions.
@end deffn

@c leave in for now --ttn
@c + @twerpdoc (pg-guile-pg-module-version)
@deffn {Scheme Procedure} pg-guile-pg-module-version
Return a string giving the version of the scheme module @code{postgres.scm}.
The string is always of the form "M.m" giving major and minor versions.
Unless something is wrong with the installation, this should be the same as
@code{pg-guile-pg-version}.
@end deffn

@c leave in for now --ttn
@c + @twerpdoc (pg-guile-pg-module-config-stamp)
@deffn {Scheme Procedure} pg-guile-pg-module-config-stamp
Return a string containing the date and time at which @code{guile-pg}
was configured (this is probably the build time).
@end deffn

@twerpdoc (pg-trace)

@twerpdoc (pg-untrace)

@heading Example
This example defines a pair of procedures @code{trace-on} and
@code{trace-off} which implement a higher-level trace procedure which
opens the required file and starts/stops the trace.

@lisp
(define (trace-on conn filename)
  (let ((port (open-file filename "w")))
    (pg-set-client-data! conn port)
    (pg-trace conn port)))

(define (trace-off conn)
  (let ((port (pg-get-client-data conn)))
    (and port
         (begin
           (close-port port)
           (pg-untrace conn)))))
@end lisp

@c ---------------------------------------------------------------------------
@node    Types Conversion
@chapter Types Conversion

Normally, the result of a @code{pg-exec} query is an object from which Scheme
strings can be extracted to represent the datum from a particular tuple/field
coordinate, using @code{pg-getvalue} (@pxref{Retrieving Data}).  If this
string is sufficient for your needs, you can skip this chapter, which
describes how to use the PostgreSQL-to-Scheme (and back) type conversion
support installed with Guile-PG, including how to register new converters.

To get started, load the @code{postgres-types} module:

@lisp
(use-modules (database postgres-types))
@end lisp

But before we get to conversions, recall that the @code{pg-ftype} example
defines a procedure that returns the name of a PostgreSQL type by doing a
query on the @code{pg_type} (internal) table.  Here is a more efficient
implementation:

@lisp
(define (pg-ftype-name result fnum)
  (assq-ref (oid-type-name-cache (pg-get-connection result))
            (pg-ftype result fnum)))
@end lisp

It uses a bonus procedure in this module:

@twerpdoc (oid-type-name-cache)

@section Consulting Existing Type Converters

To see what type converters are already defined, use the @code{dbcoltypes}
procedure.  To get a @dfn{type-converter object} that encapsulates the name,
the @dfn{stringifier}, the @dfn{objectifier} and the @dfn{default}, use
@code{dbcoltype-lookup}.  The components of the returned object can be read
using the @code{dbcoltype:FOO} procedures.

@twerpdoc (dbcoltypes)
@twerpdoc (dbcoltype-lookup)
@twerpdoc (dbcoltype:name)
@twerpdoc (dbcoltype:stringifier)
@twerpdoc (dbcoltype:objectifier)
@twerpdoc (dbcoltype:default)

Here is a simple example that uses @code{dbcoltype-lookup} and
@code{dbcoltype:objectifier} to convert a @code{text[][]} value
into a nested list:

@lisp
(let ((raw (pg-getvalue result 0 0))
      (conv (dbcoltype:objectifier (dbcoltype-lookup 'text[][]))))
  (write-line raw)
  (write-line (conv raw)))

@print{} @{@{a,b@},@{c,d@}@}
@print{} (("a" "b") ("c" "d"))
@end lisp

Note that even though the type is an "array", as implied by the square
brackets, the result is a list.  This is mostly due to a limitation in
PostgreSQL: dimensionality is not stored for array types, so the conversion
cannot be done in a random-access manner.  Perhaps this will change in the
future.

@section Defining New Type Converters

To define a new non-array type means associating with the type name a
procedure for converting from a PostgreSQL string representation to a Scheme
object (the @dfn{objectifier}), a procedure to do the conversion in the
opposite direction (the @dfn{stringifier}), and a default string to use if
none is specified (for example, during an @code{INSERT} operation).  For this,
use the @code{define-db-col-type} procedure.

@twerpdoc (define-db-col-type)

To express conversion of arrays (no matter the dimensionality) of non-array
types, use the @code{define-db-col-type-array-variant} procedure.

@twerpdoc (define-db-col-type-array-variant)

@c ---------------------------------------------------------------------------
@node    Column Definitions
@chapter Column Definitions

A column definition, or @dfn{def} for short, associates a column name, its
type and any additional options.  It has the form:

@lisp
(NAME TYPE [OPTIONS...])
@end lisp

@var{name} and @var{type} are symbols specifying the name and type of the
column, respectively (@pxref{Types Conversion}).  @var{options} are strings
passed directly to PostgreSQL as part of a @code{CREATE TABLE} command.  For
example, the status output of the rsync(1) program can be specified by the
form:

@lisp
(define rsync-defs
        '((time            timestamp)
          (error_condition text)
          (files           text[])
          (wrote           int4)          ; bytes
          (read            text[][])
          (rate            float4)
          (total           int4)          ; bytes
          (speedup         float4)
          (etc             int4[])))
@end lisp

Likewise, here is an example that might be useful in keeping a table of
expenses (although probably using @code{float4} is not a good idea for
monetary values):

@lisp
(define expense-ledger-defs
        '((i       serial)
          (date    timestamp)
          (amount  float4)
          (details text[])))
@end lisp

Note that there are no options in these examples.  The components of a def can
be extracted with procedures in the @code{postgres-col-defs} module, which can
be loaded like so:

@lisp
(use-modules ((database postgres-col-defs)
              #:renamer (symbol-prefix-proc 'def:)))
@end lisp

In this example, we use the @code{:renamer} clause to systematically prefix
"def:" to the names that the client module would see (resulting in
@code{def:column-name} and so on).

@twerpdoc (column-name)
@twerpdoc (type-name)
@twerpdoc (type-options)

There are two more convenience procedures, the first one useful in
transforming the results of a query into Scheme objects (@pxref{Result
Transforms}):

@twerpdoc (objectifiers)
@twerpdoc (stringifiers)

@c ---------------------------------------------------------------------------
@node    Result Transforms
@chapter Result Transforms

To support handling of query results in the @dfn{Scheme domain}, Guile-PG
provides various procedures to walk the result object, to extract Scheme
objects from the result object, and to collect these in idiomatic data
structures (such as the association list).

To get started, load the @code{postgres-resx} module:

@lisp
(use-modules (database postgres-resx))
@end lisp

The most basic procedure is @code{for-each-tuple}, useful for quick searches
on the unconverted result strings.

@twerpdoc (for-each-tuple)

The rest of the procedures in this chapter combine conversion of the raw
result strings to Scheme objects, with different collection methods.
@xref{Types Conversion}.  The examples are based upon a result object that can
briefly described as:

@itemize
@item two tuples each with two fields
@item field names: "date" and "note"
@item first tuple's date: "2003-01-14 00:00:00-08"
@c                         1042531200
@item first tuple's note: "now", "the present"
@item second tuple's date: "2003-01-13 00:00:00-08"
@c                          1042444800
@item second tuple's note: "yesterday", "the past"
@end itemize

The defs (@pxref{Column Definitions}) for the examples are:

@lisp
(define defs '((date timestamp) (note text[])))
@end lisp

Actually the @code{note} field in its raw form involves curly braces and extra
quoting, but we omit that to reduce clutter.

The @code{result-field->object-list} procedure is useful for single-column
queries.

@twerpdoc (result-field->object-list)

@heading Example
@lisp
(define (1-col result fn type)
  (let ((objectifier (dbcoltype:objectifier (dbcoltype-lookup type))))
    (result-field->object-list result fn objectifier)))

(1-col result 0 'timestamp)
@result{} (1042531200 1042444800)

(1-col result 1 'text[])
@result{} (("now" "the present") ("yesterday" "the past"))
@end lisp

The @code{result->object-alist} and @code{result->object-alists} procedures
have the same signature but return the data differently.

@twerpdoc (result->object-alist)
@twerpdoc (result->object-alists)

@heading Example
@lisp
(use-modules ((database postgres-col-defs) #:select (objectifiers)))

(define odefs (objectifiers defs))

(result->object-alist result odefs)
@result{}
((date 1042531200 1042444800)
 (note ("now" "the present") ("yesterday" "the past")))

(result->object-alists result odefs)
@result{}
(((date . 1042531200) (note "now" "the present"))
 ((date . 1042444800) (note "yesterday" "the past")))
@end lisp

@c ---------------------------------------------------------------------------
@node    Single-Table Abstraction
@chapter Single-Table Abstraction

For some database usages, it is convenient to focus on a single table, adding
rows to it or drawing queries from it exclusively of any other tables in the
database.  This chapter describes Guile-PG facilities for this kind of use.

To get started, load the @code{postgres-table} module:

@lisp
(use-modules (database postgres-table))
@end lisp

Basically, the @code{pgtable-manager} procedure encapsulates specification,
query and mutation (including create/delete) of a PostgreSQL table.

@twerpdoc (pgtable-manager)

@twerpdoc (compile-outspec)

The other procedures are useful for succintly codifying queries, and
translating the result en mass to Scheme objects.  [NOTE: These will
definitely migrate to other modules at some point before 1.0 release.]

@twerpdoc (tuples-result->table)

@twerpdoc (sql-pre)

@twerpdoc (where-clausifier)

The rest of this chapter is an extended example showing some of the uses of
@code{pgtable-manager}.

@lisp
(define m (pgtable-manager "ttn" "guile_pg_demo"
                           '((i          serial)
                             (date       timestamp)
                             (amount     float4)
                             (catcode    text)
                             (details    text[]))))

((m 'create))
@result{} #<PG-RESULT:1:PGRES_COMMAND_OK:0:0>

(define add (m 'insert-col-values))
(define sel (m 'select))

(add '(date amount) (current-time) 1.98)
@result{} #<PG-RESULT:2:PGRES_COMMAND_OK:0:0>

(add '(date amount) (current-time) 2.98)
@result{} #<PG-RESULT:3:PGRES_COMMAND_OK:0:0>

(define result (sel "count(*)" (where-clausifier "amount < 2.00")))

result
@result{} #<PG-RESULT:4:PGRES_TUPLES_OK:1:1>

(tuples-result->table result)
@result{} #2(("1"))

((m 'drop))
@result{} (#<PG-RESULT:5:PGRES_COMMAND_OK:0:0> #<PG-RESULT:6:PGRES_COMMAND_OK:0:0>)
@end lisp

Two things to note in this example: (1) Both @code{create} and @code{drop}
invocations evaluate the operating thunk directly (double parentheses); and
(2) The drop returns a list of result values to accomodate the possibility
(shown here) of a @code{serial} column type, which requires an additional drop
of the associated PostgreSQL @dfn{sequence} used to implement the expected
serial behavior.  (As of PostgreSQL 7.x, the sequence name is constructed like
so: TABLENAME_COLNAME_seq.  For more info, see the PostgreSQL User Guide,
Chapter 3: Data Types.

@c ---------------------------------------------------------------------------
@node    Introspection
@chapter Introspection

This chapter explains the introspection facilities, which admittedly are not
(yet) very well developed in Guile-PG.  [During the alpha releases, these will
surely change quite a bit; your feedback is welcome.]

To get started, load the @code{postgres-meta} module:

@lisp
(use-modules (database postgres-meta))
@end lisp

The column definitions of an existing table can be discovered to some extent by
the @code{infer-defs} and @code{describe-table!} procedures, the latter also
displaying details on field/column innards.

@twerpdoc (infer-defs)
@twerpdoc (describe-table!)

@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@c + @node       Concept Index
@c + @unnumbered Concept Index
@c +
@c + @printindex cp

@c ---------------------------------------------------------------------------
@node       Procedure Index
@unnumbered Procedure Index

@printindex fn

@contents

@bye
