\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename guile-pg.info
@settitle The (database postgres*) Modules
@paragraphindent 0
@c %**end of header
@code{}
@setchapternewpage odd

@c Error index.
@defcodeindex er

@dircategory Guile modules
@direntry
* Guile-PG: (guile-pg).           Access to PostgreSQL databases from Guile.
@end direntry

@ifinfo
This file is the Reference Guide for the (database postgres*) Modules.

Copyright @copyright{} 1998 Ian Grant
Copyright @copyright{} 2002, 2003, 2004, 2005 Thien-Thi Nguyen

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and
print the results, provided the printed document carries a copying
permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end ifinfo
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The (database postgres*) Modules}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998 Ian Grant
Copyright @copyright{} 2002, 2003, 2004, 2005 Thien-Thi Nguyen

     Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice are
preserved on all copies.

     Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled ``Copying'' and ``GNU General Public
License'' are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

     Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@c ---------------------------------------------------------------------------
@node Top
@top  The (database postgres*) Modules

Guile-PG is a collection of modules for Guile allowing access to the
PostgreSQL RDBMS (@url{http://www.postgresql.org}) from Scheme programs.

The low-level module @code{(database postgres)} provides an almost one-to-one
correspondence with the PostgreSQL @code{libpq} C library interface.  Other
higher-level modules, typically named @code{(database postgres-FOO)}, provide
abstractions and convenience procedures.

@menu
* Legalities::                  Your rights and freedoms.
* Quick Start::                 Overview and brief examples.

* Database Connections::        Groundwork for database interaction.
* Retrieving Data::             Making queries and accessing results.
* Writing/Reading Data::        Bulk data movement and I/O.
* Large Objects::               Large-Object support.
* Miscellaneous::               Everything else starting with "pg-".

* Query Construction::          Module: (database postgres-qcons).
* Displaying Results::          Module: (database postgres-resdisp).
* Types Conversion::            Module: (database postgres-types).
* Column Definitions::          Module: (database postgres-col-defs).
* Result Transforms::           Module: (database postgres-resx).
* Single-Table Abstraction::    Module: (database postgres-table).
* Introspection::               Module: (database postgres-meta).
* Easy Interaction::            Module: (database postgres-gxrepl).

* Procedure Index::
* Error Index::
@end menu

@c ---------------------------------------------------------------------------
@node    Legalities
@chapter Legalities

Guile-PG is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

Guile-PG is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Guile-PG; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

@c ---------------------------------------------------------------------------
@node    Quick Start
@chapter Quick Start

To access a PostgreSQL database from Guile, first load the @code{postgres}
database module.  This is done using the @code{use-modules} syntax:

@lisp
(use-modules (database postgres))
@end lisp

The next step is to make a connection to the database using the
@code{pg-connectdb} procedure.  Then, having created a valid connection to a
database server, we can use the @code{pg-exec} procedure to execute
queries and the other @code{pg-} procedures to retrieve the results of the
queries.

The following Guile session opens a connection and executes an
SQL statement on the @code{test} database on the default host (either
@code{localhost} or the host specified in the @code{PGHOST} environment
variable.)

@cartouche
@example
guile> (use-modules (database postgres))
guile> (define test (pg-connectdb "dbname=test"))
guile> test
#<PG-CONN:1:test::5432:>
guile> (define result (pg-exec test "SELECT * FROM PEOPLE"))
guile> result
#<PG-RESULT:1:TUPLES_OK:3:5>
@end example
@end cartouche

The @code{test} object is a @code{PG-CONN} type representing the database
connection.  Displaying the @code{PG-CONN} object shows that the serial number
of the connection is 1, that the database name is @code{test} on the default
host (the hostname field is empty) on port number 5432 and that the default
options were passed to the backend.  This object is passed to @code{pg-exec}
which returns a @code{PG-RESULT} object representing the result of the SQL
statement executed on the server.  In this case, displaying the @code{PG-RESULT}
object shows us that the serial number of the result is 2, that the return code
from the database was @code{PGRES_TUPLES_OK} and that we have received 3 tuples
with 5 fields.

Having obtained a result object from the database we can find out how
many rows and how many columns are in the result.  We can also find out the
names of the columns:

@cartouche
@example
guile> (pg-ntuples result)
3
guile> (pg-nfields result)
5
guile> (pg-fname result 0)
"surname"
guile> (pg-fname result 1)
"firstname"
@end example
@end cartouche

To retrieve the data from the result we use the @code{pg-getvalue} procedure.
This takes a result object along with the row and column numbers and returns a
string containing that value.  @code{pg-getvalue} always returns a string: it
is up to the caller to convert this to whatever type they require.

@cartouche
@example
guile> (pg-getvalue result 0 0)
"Bitdiddle"
guile> (pg-getvalue result 0 1)
"Ben"
guile> (pg-getvalue result 1 0)
"Ator"
guile> (pg-getvalue result 1 1)
"Eva Lu"
@end example
@end cartouche

Guile-PG connections are closed when Guile's garbage collector
collects the discarded object.  This only happens when the connection itself
and all of the results of @code{pg-exec} are unreachable.  So to close the
connection we just rebind the results from that connection and the connection
symbol itself:

@cartouche
@example
guile> (define result '())
guile> (define test '())
@end example
@end cartouche

Typically though the result and connection variables will be @code{let}
bindings so the connection will usually be closed soon after the body of the
@code{let} returns.

@c ---------------------------------------------------------------------------
@node    Database Connections
@chapter Procedures for managing connections

All sessions with a PostgreSQL database require a connection to be opened with
@code{pg-connectdb}.  When the default values of the options are sufficient,
you don't need to specify them.  Default values are also useful in creating a
connection dialog (user-interface element).

Guile-PG displays connection objects in the following format:

@example
#<PG-CONN:N:DB:HOST:PORT:OPTIONS>
@end example

@var{n} is the serial number of the connection, valid only for the current
session; @var{db} is the database name, or @code{?}; @var{host} is the host
name, empty in the case of unix-domain connections; @var{port} is the TCP port
where the server is listening, empty in the case of unix-domain connections;
and @var{options} is the same as would be returned by @code{pg-get-options}.
Everything else appears literally as shown here.  It is very strange to have
@var{db} be @code{?}; usually that indicates a bug either in Guile-PG or in
PostgreSQL.

@twerpdoc (pg-connection?)
@erindex due to bad connection
@twerpdoc (pg-connectdb)
@twerpdoc (pg-conndefaults)

@heading Example
@lisp
(define (user-count host tcp-port)
  (let* ((conn (pg-connectdb
                (format #f "host=~A port=~A dbname=template1"
                        host tcp-port)))
         (result (pg-exec conn "SELECT COUNT(*) FROM pg_user")))
    (and result
         (eq? 'PGRES_TUPLES_OK (pg-result-status result))
         (string->number (pg-getvalue result 0 0)))))
@end lisp

Notices are messages sent from the back- to the front-end, sometimes prefixed
with the word @code{NOTICE}, and always followed by a trailing newline.  By
default, they are sent to the current output port.

@twerpdoc (pg-set-notice-out!)

@twerpdoc (pg-reset)

@twerpdoc (pg-get-db)

@twerpdoc (pg-get-user)

@twerpdoc (pg-get-pass)

@twerpdoc (pg-get-host)

@twerpdoc (pg-get-port)

@twerpdoc (pg-get-tty)

@twerpdoc (pg-get-options)

@twerpdoc (pg-backend-pid)

@section Client Data

The libpq interface upon which Guile-PG is built supports assocation of
arbitrary data with a connection.  You can use these @dfn{client data}
procedures or the more general @dfn{object property} procedures in Guile.

@twerpdoc (pg-get-client-data)

@twerpdoc (pg-set-client-data!)

@heading Example
The following is a set of three procedures which implement a database
connection object that logs all the SQL statements it executes.

@lisp
(define (pg-connectdb/logged options)
  (let ((conn (pg-connectdb options)))
    (and conn
         (begin (pg-set-client-data! conn '())
                conn))))

(define (pg-exec/logged conn sql)
  (pg-set-client-data! conn (append (pg-get-client-data conn)
                                    (list sql)))
  (pg-exec conn sql))

(define (conn-log conn)
  (pg-get-client-data conn))
@end lisp

Here is an implementation using object properties,
using the keyword @code{#:log} as the key.

@lisp
(define put set-object-property!)
(define get object-property)

(define (pg-connectdb/logged options)
  (let ((conn (pg-connectdb options)))
    (put conn #:log '())
    conn))

(define (pg-exec/logged conn sql)
  (put conn #:log (append! (get conn #:log)
                           (list sql)))
  (pg-exec conn sql))

(define (conn-log conn)
  (get conn #:log))
@end lisp

@section Asynchronous Notifications

The PostgreSQL backend supports @dfn{asynchronous notifications}
with the commands @code{LISTEN} and @code{NOTIFY}.  You can use
@code{pg-notifies} to query the pending notifications queue
(@pxref{Asynchronous Retrieval}).

@twerpdoc (pg-notifies)

@section Character Encoding

The client's character encoding, represented by a string such as
"UNICODE", can be queried and set.

@twerpdoc (pg-client-encoding)
@twerpdoc (pg-set-client-encoding!)

@section Non-Blocking Mode

@twerpdoc (pg-set-nonblocking!)
@twerpdoc (pg-is-nonblocking?)

@c ---------------------------------------------------------------------------
@node    Retrieving Data
@chapter Procedures for Retrieving Data

To get an answer you have to ask a question, i.e., send either a command or a
query to the connection using either @code{pg-exec} or some combination of the
lower-level non-blocking operations that comprise @code{pg-exec}.

@menu
* Synchronous Retrieval::       Using @code{pg-exec}.
* Asynchronous Retrieval::      Using pieces of @code{pg-exec}.
* Processing Results::          What to do with data and/or errors.
@end menu

@c ---------------------------------------------------------------------------
@node    Synchronous Retrieval
@section Synchronous Retrieval

@twerpdoc (pg-exec)

@heading Example
This example defines a procedure @code{pg-exec/no-false} which wraps
@code{pg-exec} so that a @code{misc-error} is thrown instead of returning
false.  There are numerous other examples of @code{pg-exec} calls throughout
this chapter.

@lisp
(define (pg-exec/no-false conn sql)
  (or (pg-exec conn sql)
      (error (pg-error-message conn))))
@end lisp

@heading Notes
The entire result set is returned at once from a call to to @code{pg-exec}.
If a @code{SELECT} results in a very large number of tuples then this can be
a problem because it requires a large amount of memory.  In these cases it is
better to @code{DECLARE} a cursor over the @code{SELECT} and retrive small
numbers of rows at a time using @code{FETCH}.  These commands can only be
issued between @code{BEGIN TRANSACTION/END TRANSACTION} pairs.  See the
PostgreSQL @code{declare(l)} and @code{fetch(l)} man pages for more details.

@c ---------------------------------------------------------------------------
@node    Asynchronous Retrieval
@section Asynchronous Retrieval

Sometimes you don't want to wait idly for @code{pg-exec} to complete --- for
example, the query is complicated and/or the results are large --- instead
prefering to do some other computation in the meantime.  In these cases, you
can interact with the database @dfn{asynchronously}, that is, you register a
query at one time, and check for its completion at a later time.  In between,
you can collect partial results and notifications, or decide to cancel the
query altogether.

@twerpdoc (pg-send-query)
@twerpdoc (pg-get-result)
@twerpdoc (pg-consume-input)
@twerpdoc (pg-is-busy?)
@twerpdoc (pg-request-cancel)

@c ---------------------------------------------------------------------------
@node    Processing Results
@section Processing Results

The @dfn{result} of a command or query placed by @code{pg-exec} satisfies
predicate @code{pg-result?}.  It may encapsulate an error, row data, or other
status.  @xref{Retrieving Data}.

Guile-PG displays result objects in the following format:

@example
#<PG-RESULT:N:STATUS:NTUPLES:NFIELDS>
@end example

@var{n} is the serial number of the result, valid only for the current
connection; @var{status} is the same as would be returned by
@code{pg-result-status} except without the @code{PGRES_} (it is
redundant); @var{ntuples} and @var{nfields} are integers,
the same as would be returned by @code{pg-ntuples} and @code{pg-nfields},
respectively.  Everything else appears literally as shown here.

@twerpdoc (pg-result?)

@twerpdoc (pg-result-error-message)

@twerpdoc (pg-error-message)

@twerpdoc (pg-result-status)

@heading Result Status Values
@table @code

@item PGRES_TUPLES_OK
The statement returned zero or more tuples.  The number of fields and tuples
returned can be determined from calls to @code{pg-nfields} and
@code{pg-ntuples} respectively.  The value of a given attribute (field)
of a given tuple can be determined by calling @code{pg-getvalue}.

@item PGRES_COMMAND_OK
The statement was a command (@code{INSERT}, @code{UPDATE}, @code{DELETE}
@code{CREATE TABLE}, @code{DROP TABLE} etc.),
which was executed without error.  The number of tuples affected by the
command can be determined by a call to @code{pg-cmdtuples}.

@item PGRES_EMPTY_QUERY
It is not known under which circumstances this result-status is returned.

@item PGRES_COPY_OUT
The statement was a @code{COPY <table> TO STDOUT}.  The data can be read using
@code{pg-getline} or @code{pg-getlineasync}.

@item PGRES_COPY_IN
The statement was a @code{COPY <table> FROM STDIN}.  The rows should be written
using @code{pg-putline}.

@item PGRES_BAD_RESPONSE
This occurs when the @code{libpq} interface receives an unexpected response
from the backend.  It indicates a problem with PostgreSQL.

@item PGRES_NONFATAL_ERROR
It is not known under which circumstances this result-status is returned.

@item PGRES_FATAL_ERROR
The command was not executable for some reason.  This is the returned status
when a syntax error is detected in the command, for example.

@end table

@heading Example
This contrived example defines a procedure to insert a record into a given
table, returning the number of tuples inserted (always one) or @code{#f} if an
error occurred.

@lisp
(define (insert-one-record conn table record)
  (let ((result (pg-exec conn
                         (format #f "INSERT INTO ~A VALUES ~A"
                                 table record))))
    (and result
         (eq? 'PGRES_COMMAND_OK (pg-result-status result))
         (string->number (pg-cmdtuples result)))))
@end lisp

The procedure could be called as follows

@lisp
(insert-one-record conn "people" "('Warbucks', 'Oliver')")
@end lisp

@twerpdoc (pg-get-connection)

@twerpdoc (pg-binary-tuples?)

@erindex Invalid field number
The procedures @code{pg-fmod}, @code{pg-ftype}, @code{pg-fname}
and @code{pg-fsize} can all throw an @dfn{Invalid field number} error.

@twerpdoc (pg-fmod)

@twerpdoc (pg-ntuples)

@twerpdoc (pg-nfields)

@twerpdoc (pg-cmdtuples)

@twerpdoc (pg-oid-value)

@twerpdoc (pg-fname)

@twerpdoc (pg-fnumber)

@twerpdoc (pg-getvalue)

This example defines a procedure @code{tuple->alist} which returns a given
tuple as an alist, keyed on the field name.  It's not an especially efficient
procedure because it constructs the list of field-names afresh each time it's
called.

@lisp
(define (field-names result)
  (map (lambda (field)
         (pg-fname result field))
       (iota (pg-nfields result))))

(define (get-values result tuple)
  (map (lambda (field)
         (pg-getvalue result tuple field))
       (iota (pg-nfields result))))

(define (tuple->alist result tuple)
  (map (lambda (n v) (cons (string->symbol n) v))
       (field-names result)
       (get-values result tuple)))
@end lisp

Field values can be extracted from the tuple using @code{assq-ref}, eg:

@lisp
(assq-ref (tuple->alist result 0) 'firstname)
@end lisp

Using this procedure we can define a version of @code{for-each} which
iterates through the tuples returned from a given @code{SELECT} query:

@lisp
(define (for-each-tuple proc result)
  (let ((end (pg-ntuples result)))
    (do ((tuple 0 (1+ tuple)))
        ((= tuple end))
      (proc (tuple->alist result tuple)))))
@end lisp

This implementation of @code{for-each-tuple} inherits inefficiency from the
@code{tuple->alist} procedure.

@heading Notes
The @code{pg-getvalue} procedure throws
@code{out-of-range} errors if either the @code{tuple} or @code{field-number}
arguments are out of range.

@twerpdoc (pg-getisnull)

@twerpdoc (pg-ftype)

@heading Example
This defines a procedure @code{field-type-name} which returns the type
name of a given attribute in a string.

A more efficient implementation would be to define
a type of connection which, when opened, issued the query to retrieve the
@code{pg_type} system table once.  An alist for looking up type names could
then be associated with each connection using @code{pg-set-client-data!}.

@lisp
(define (field-type-name result fnum)
  (let ((result (pg-exec
                 (pg-get-connection result)
                 (format #f "SELECT typname FROM pg_type WHERE oid = ~A"
                         (pg-ftype result fnum)))))
    (or (and result
             (eq? 'PGRES_TUPLES_OK (pg-result-status result))
             (< 0 (pg-ntuples result))
             (pg-getvalue result 0 0))
        "")))
@end lisp

@twerpdoc (pg-fsize)

@twerpdoc (pg-getlength)

@c ---------------------------------------------------------------------------
@node    Writing/Reading Data
@chapter Procedures for Copying Data

There are two procedures for reading a line of data associated with the
command @code{COPY <table> TO STDOUT}.  For both, when the @dfn{end-of-copy
marker} is recognized, that means the results from the @code{COPY} command
have all been read and @code{pg-endcopy} should be called to resynchronize the
connection before any further calls to @code{pg-exec} on this connection.

@twerpdoc (pg-getline)
@twerpdoc (pg-getlineasync)

@heading Example
This example defines two functionally identical procedures that can be used
to retrieve the results of a @code{COPY <table> TO STDOUT} command.  The
second procedure optionally displays a list of received chunk sizes, if
passed a third arg.

@lisp
(define (copy-to-port conn port)
  (let loop ((line (pg-getline conn)))
    (if (string=? line "\\.")
        (pg-endcopy conn)
        (begin (format port "~A\n" line)
               (loop (pg-getline conn))))))

(define (copy-to-port-async conn port . show-chunk-sizes?)
  (let ((buf (make-string 32)))
    (let loop ((count (pg-getlineasync conn buf))
               (chunks '()))
      (if (< count 0)
          (begin
            (or (null? show-chunk-sizes?)
                (format port "chunk sizes: ~S\n" chunks))
            (pg-endcopy conn))
          (begin
            (display (substring buf 0 count) port)
            (loop (pg-getlineasync conn buf #t)
                  (cons count chunks)))))))
@end lisp

@heading Notes
It is an error to call @code{pg-getline} on a connection without first
executing a @code{COPY <table> TO STDOUT} command on that connection.
It is also an error to call @code{pg-getline} after a terminating line has
been received, without an intervening @code{COPY} command being issued on
that connection.

@twerpdoc (pg-putline)

@heading Example
This example defines a procedure @code{copy-from-port} which can be used
to supply data to a @code{COPY <table> FROM STDIN} command.

@lisp
(use-modules (ice-9 rdelim))

(define (copy-from-port conn port)
  (let loop ((line (read-line port)))
    (cond ((eof-object? line)
           (pg-putline conn "\\.\n")
           (pg-endcopy conn))
          (else
           (pg-putline conn line)
           (pg-putline conn "\n")
           (if (string=? line "\\.")
               (pg-endcopy conn)
               (loop (read-line port)))))))
@end lisp

@twerpdoc (pg-endcopy)

Although not readily apparent, another form of data copying is @dfn{formatted
output}, which is supported by Guile-PG via the @code{pg-print} procedure and
the accompanying @code{pg-make-print-options}.  Together these loosely mimic
the @code{PQprint} functionality provided by libpq.

@twerpdoc (pg-make-print-options)

@erindex due to @code{tmpfile(3)} failure
@twerpdoc (pg-print)

@c ---------------------------------------------------------------------------
@node    Large Objects
@chapter Procedures for Managing Large Objects

@heading Note
All of the operations on large objects must be carried out inside a
@code{BEGIN TRANSACTION/END TRANSACTION} pair.  Failure to do this
will result in a loss of synchronisation between the backend and the
@code{libpq} library, resulting in an unusable connection to the
database, and possible corruption of data.

@erindex lob flush
@erindex Error seeking on lo port
@erindex Error reading from lo port
@erindex fport_write
To keep things running smoothly, certain read and write operations flush their
internal buffers every once in a while.  If there are problems, they throw a
@dfn{lob flush} error.  In the case where an error occurs during the process
(Guile) wind-down, the error message is displayed to stderr instead.  There
are also @dfn{Error seeking on lo port}, @dfn{Error reading from lo port}
and @dfn{fport_write}; these are normal (scheme world) errors.

@erindex Invalid mode specification
@erindex memory error
Additionally, both @code{pg-lo-creat} and @code{pg-lo-open} can throw
@dfn{Invalid mode specification} and @dfn{memory} errors.

Guile-PG displays large-object port objects in the following format:

@example
#<PG-LO-PORT:MODE: ALOD:OID:CONN>
@end example

@var{mode} is one of @code{closed}, @code{input-output}, @code{input},
@code{output} or @code{bogus}; @var{alod} is a large-object descriptor (small
integer similar to a file descriptor); @var{oid} is the OID (integer); and
@var{conn} is the printed representation of the connection (@pxref{Database
Connections}).  Everything else appears literally as shown here (including the
space in front of @var{alod}, unfortunately).  This format will likely change
by the time Guile-PG 1.0 is released.

@twerpdoc (pg-lo-creat)

@twerpdoc (pg-lo-open)

@twerpdoc (pg-lo-unlink)

@twerpdoc (pg-lo-get-connection)

@twerpdoc (pg-lo-get-oid)

@twerpdoc (pg-lo-tell)

@twerpdoc (pg-lo-seek)

@heading Note
It is possible to seek beyond the end of file opened only for reading, in
which case subsequent reads of the port will return an EOF object.

@twerpdoc (pg-lo-read)

@twerpdoc (pg-lo-import)

@twerpdoc (pg-lo-export)

@c ---------------------------------------------------------------------------
@node    Miscellaneous
@chapter Miscellaneous Procedures

This chapter describes procedures whose name begins with "pg-" that do not
necessarily belong in the other chapters.

@twerpdoc (pg-guile-pg-loaded)

@erindex due to @code{dup(3)} failure
@erindex due to @code{fopen(3)} failure
@twerpdoc (pg-trace)

@erindex due to @code{fclose(3)} failure
@twerpdoc (pg-untrace)

@heading Example
This example defines a pair of procedures @code{trace-on} and
@code{trace-off} which implement a higher-level trace procedure which
opens the required file and starts/stops the trace.

@lisp
(define (trace-on conn filename)
  (let ((port (open-file filename "w")))
    (pg-set-client-data! conn port)
    (pg-trace conn port)))

(define (trace-off conn)
  (let ((port (pg-get-client-data conn)))
    (and port
         (begin
           (close-port port)
           (pg-untrace conn)))))
@end lisp

@c ---------------------------------------------------------------------------
@node    Query Construction
@chapter Query Construction

Constucting a typical SQL @code{SELECT} query (to be passed to @code{pg-exec})
can be tedious and error prone due to the many string-munging operations
involved.  Guile-PG provides some procedures to make things a little easier.

To get started, load the @code{postgres-qcons} module:

@lisp
(use-modules (database postgres-qcons))
@end lisp

This provides procedures to render @dfn{prefix-style expressions} to SQL
syntax, essentially by constructing stylized trees (nested lists) and then
flattening them to a string on output.

@section Prefix-Style Expressions

To be brutally honest, both SQL and Scheme revolve around structured
expressions (also known as @dfn{sexps}), so ascribing some elevated status to
the representation that ``supports sexps'' is really not saying much.  In the
Guile-PG maintainer's humble opinion, the advantage in expressivity of Scheme
over SQL is not in the presence or lack of structure, but rather in the
regularity of the structure.

Scheme syntax is (as you probably already know) exceedingly easy to describe:
first there is the opening parenthesis, then the operator or function, then
the argument(s), and finally the matching closing parenthesis.  The
argument(s) can in turn be sub-expressions of their own.  This simplicity
stands in stark contrast to the myriad rules (and worse: exceptions to the
rules) that comprise the SQL language specification.

Thus, we call the mini-language described in this chapter @dfn{prefix-style
expressions} because it borrows from Scheme's regularity even though it is not
Scheme, per se.  This is the general form of a prefix-style expression:

@example
(operator [operand ...])
@end example

In words: An open paren followed by a symbol @var{operator} followed by zero
or more @var{operand} arguments, each in turn a prefix-style sub-expression,
followed by the close paren.  Components of these expressions may be symbols,
keywords, numbers, strings and matching parens.  Unlike Scheme, there is no
quote, quasiquote, unquote or unquote-splicing, although those facilities can
(and should) be used in a Scheme program to construct a prefix-style
expression.  Also unlike Scheme is the requirement that @var{operator} be a
symbol; it is not processed in the same way as each @var{operand}.

Usually, @var{operator} names an SQL function or operator.  For example,
the symbol @code{date_trunc} refers to the SQL function by the same name.
Guile-PG uses lookup tables to determine how to transform the prefix style
into either infix, postfix, functional or other layouts.  Some operators are
handled specially:

@table @code
@item and
@itemx or
These infix operators are very common and are only mentioned because they do
not show up in the lookup tables.  (Do not be alarmed!)

@item (case PEXP (MAYBE1 VAL1) ... [(else DEFAULT-VAL)])
This maps to the SQL @code{CASE} statement:

@example
CASE exp
 WHEN maybe1 THEN val1 ...
 ELSE default
END
@end example

where the changes from @code{PEXP}, @code{MAYBE1}, @code{VAL1} and
@code{DEFAULT-VAL} to @code{exp}, @code{maybe1}, @code{val1} and
@code{default}, respectively, involve recursive layout transforms.

@item (cond (MAYBE1 VAL1) ... [(else DEFAULT-VAL)])
This maps to the SQL @code{CASE} statement without the initial pexp:

@example
CASE
 WHEN maybe1 THEN val1 ...
 ELSE default
END
@end example

where the changes from @code{MAYBE1}, @code{VAL1} and
@code{DEFAULT-VAL} to @code{maybe1}, @code{val1} and
@code{default}, respectively, involve recursive layout transforms.

@item (if PEXP YES-VAL NO-VAL)
This maps to the SQL @code{CASE} statement:

@example
CASE exp
 WHEN 't' THEN yes
 WHEN 'f' THEN no
END
@end example

where the changes from @code{PEXP}, @code{YES-VAL} and
@code{NO-VAL} to @code{exp}, @code{yes} and
@code{no}, respectively, involve recursive layout transforms.
Note that @dfn{one-armed if} is not permitted.

@item (:: TYPE PEXP)
This maps to the SQL @code{CAST} statement:

@example
CAST exp AS type
@end example

where the change from @code{PEXP} to @code{exp} involves a recursive layout
transform.  Note that the result is identical to using (SQL) suffix
@code{::TYPE}; the operator @code{::} was actually chosen with this
mnemonic in mind.
@end table

A symbol appearing in the operands, or alone without parentheses (i.e., in a
non-operator position), it is taken to be a column name or reference.

Strings are always passed through @code{sql-quote} unless they have been
previously been passed through @code{sql-pre}.

Numbers are passed through w/o change.

The documentation for the procedures described in this chapter often uses
@dfn{pexp} to stand for prefix-style expression.  Some procedures take a pexp
(or list of them), while others take a more complex structure usually
involving some extra specification composed with a single pexp.

@section Lookup Tables Extension

During tree construction, internal lookup tables control the rendering
transformations.  You can add to them using proc @code{qcons-declare!}.

@twerpdoc (qcons-declare!)

The rest of this section presents various lists of built-in declarations.
Using @code{qcons-declare!} on a built-in symbol overwrites the associated
value (if any).  There is no @dfn{undeclare} support.

@include qcons-tables.texi

@section Quoting

Ideally, the tree construction procedures in the following section would
be powerful enough to do the right thing given a well-formed prefix-style
expression.  However, sometimes reality intrudes and you need to craft SQL
directly.  In these cases, it still may be a good idea to use the tree
construction procs for most of the work and tweak only the small parts that
need it.  This selective use of varying expression construction approaches is
known prosaically as @dfn{quoting}.

@twerpdoc (sql-pre)
@twerpdoc (sql-pre?)
@twerpdoc (sql-unpre)
@twerpdoc (sql-quote)

@section Tree Construction

This section describes the tree construction procedures, most of which are
still (at this time, 2005-02-24) considered @emph{experimental}.  You should
take this as an invitation to @emph{experiment} and share your observations w/
the Guile-PG maintainer so that we can refine them nicely for the 1.0 release.

@twerpdoc (make-comma-separated-tree)
@twerpdoc (make-WHERE-tree)
@twerpdoc (make-GROUP-BY-tree)
@twerpdoc (make-HAVING-tree)
@twerpdoc (make-ORDER-BY-tree)
@twerpdoc (make-SELECT/COLS-tree)
@twerpdoc (make-FROM-tree)
@twerpdoc (make-SELECT/FROM/COLS-tree)
@twerpdoc (parse+make-SELECT/tail-tree)
@twerpdoc (parse+make-SELECT-tree)

@section Output

To get SQL once the tree is constructed, you have to flatten it.

@twerpdoc (sql<-trees)
@twerpdoc (sql-command<-trees)

@c ---------------------------------------------------------------------------
@node    Displaying Results
@chapter Displaying Results

If procedure @code{pg-print} does not do what you want (@pxref{Writing/Reading
Data}), you can try a slightly more customizable method for displaying
results.

To get started, load the @code{postgres-resdisp} module:

@lisp
(use-modules (database postgres-resdisp))
@end lisp

@twerpdoc (display-result)

@c ---------------------------------------------------------------------------
@node    Types Conversion
@chapter Types Conversion

Normally, the result of a @code{pg-exec} query is an object from which Scheme
strings can be extracted to represent the datum from a particular tuple/field
coordinate, using @code{pg-getvalue} (@pxref{Retrieving Data}).  If this
string is sufficient for your needs, you can skip this chapter, which
describes how to use the PostgreSQL-to-Scheme (and back) type conversion
support installed with Guile-PG, including how to register new converters.

To get started, load the @code{postgres-types} module:

@lisp
(use-modules (database postgres-types))
@end lisp

But before we get to conversions, recall that the @code{pg-ftype} example
(@pxref{Processing Results})
defines a procedure that returns the name of a PostgreSQL type by doing a
query on the @code{pg_type} (internal) table.  Here is a more efficient
implementation:

@lisp
(define (pg-ftype-name result fnum)
  (assq-ref (oid-type-name-cache (pg-get-connection result))
            (pg-ftype result fnum)))
@end lisp

It uses a bonus procedure in this module:

@twerpdoc (oid-type-name-cache)

@menu
* Consulting Existing Type Converters::
* Selected Notes About Some Types::
* Defining New Type Converters::
@end menu

@node    Consulting Existing Type Converters
@section Consulting Existing Type Converters

To see what type converters are already defined, use the @code{dbcoltypes}
procedure.  To get a @dfn{type-converter object} that encapsulates
the @dfn{stringifier}, the @dfn{objectifier} and the @dfn{default}, use
the procedure
@code{dbcoltype-lookup}.  The components of the returned object can be read
using the @code{dbcoltype:FOO} procedures.

@twerpdoc (dbcoltypes)
@twerpdoc (dbcoltype-lookup)
@twerpdoc (dbcoltype:stringifier)
@twerpdoc (dbcoltype:objectifier)
@twerpdoc (dbcoltype:default)

Here is a simple example that uses @code{dbcoltype-lookup} and
@code{dbcoltype:objectifier} to convert a @code{text[][]} value
into a nested list:

@lisp
(let ((raw (pg-getvalue result 0 0))
      (conv (dbcoltype:objectifier (dbcoltype-lookup 'text[][]))))
  (format #t "~A\n~A\n" raw (conv raw)))

@print{} @{@{a,b@},@{c,d@}@}
@print{} (("a" "b") ("c" "d"))
@end lisp

Note that even though the type is an "array", as implied by the square
brackets, the result is a list.  This is mostly due to a limitation in
PostgreSQL: dimensionality is not stored for array types, so the conversion
cannot be done in a random-access manner.  Perhaps this will change in the
future.

@node    Selected Notes About Some Types
@section Selected Notes About Some Types

For the most part, the built-in converters map Scheme types to PostgreSQL
types almost transparently (@pxref{Consulting Existing Type Converters}).
This section lists the PostgreSQL types not (yet) covered, describes the major
weakness in the mapping approach, and then finally touches upon some of the
rough edges to be found in selected cases.  We hope to resolve these issues
(and thus be able to revise this section significantly) before Guile-PG 1.0 is
released.

Converters for the following PostgresSQL 7.3.8 types are not provided.
(Dot-separated numbers indicate a section in the PostgreSQL User's Guide
describing the type.)

@table @code

@item decimal
@itemx numeric
@itemx double precision
Numeric Types (5.1).  Guile-PG provides @code{double} instead of @code{double
precision}.  Guile supports bignums, so the @code{decimal} and @code{numeric}
converters can probably be provided w/ a SMOP.

@item money
Monetary Type (5.2).  Since PostgreSQL itself deprecates this type,
it is unlikely Guile-PG will support it ever.

@item character varying (n)
@itemx varchar (n)
@itemx character (n)
@itemx char (n)
Character Types (5.3).

@item bytea
Binary Strings (5.4).

@item timestamp [ (p) ] with time zone
@itemx interval [ (p) ]
@itemx date
@itemx time [ (p) ] with time zone
@itemx time [ (p) ] without time zone
Date/Time Types (5.5).

@item point
@itemx line
@itemx lseg
@itemx box
@itemx path
@itemx polygon
@itemx circle
Geometric Types (5.7).

@item bit (n)
@itemx bit varying (n)
Bit String Types (5.9).

@item regproc
@itemx regprocedure
@itemx regoper
@itemx regoperator
@itemx regclass
@itemx regtype
Object Identifier Types (5.10).

@item record
@itemx any
@itemx anyarray
@itemx void
@itemx trigger
@itemx language_handler
@itemx cstring
@itemx internal
@itemx opaque
Pseudo-Types (5.11).

@end table

The large table above hints at the major weakness in Guile-PG's type mapping
approach: the names of type converters and the names of the PostgreSQL types
are not decoupled at all.  This has several negative consequences:

@enumerate

@item Non-alphanumeric characters in the PostgreSQL type name are not handled
gracefully.  For example, @code{double precision} has a space; Guile-PG can
provide @code{double}, but now there is ambiguity upon reflection, and
the single-table abstraction @code{#:create} method fails.

@item When there is no native Guile type that maps cleanly, Guile-PG must
choose an object representation, which may not be ideal for the application.
For example, Guile-PG defines an @code{inet} object to be a two-element
vector; perhaps an application uses a cons or simply one number, since all its
@code{inet} objects are host addresses (constant netmask).  Sure, it is no big
deal to box/unbox, but that's an extra level of conversion that the whole
system was trying to avoid in the first place.

@item User-defined types can clobber internals.
(Actually, this may not be a problem in practice.)

@item Parameterized types cannot be specified.

@item Non-array derived types cannot express their lineage.
For example, Guile-PG provides @code{inet-host}, but the
single-table abstraction @code{#:create} method fails because
it has no way of finding out that this type is based on @code{inet}.

@item [probably other things i can't recall at the moment... --ttn]

@end enumerate

The rest of this section is a table delving into some of the more quirky type
converters provided, including those that do not have a PostgreSQL type.
Entries marked @code{NOCREATE} indicate that the converter is for a synthetic
type and that it cannot be used in the single-table abstraction to create a
table, either because there is no underlying PostgreSQL type, or because
information about such an underlying type is not (presently) available.
Entries marked @code{INTERNAL} are ``not intended for use by the general
user'', according to the PostgreSQL User's Guide.  Entries marked
@code{EXPERIMENTAL} should probably be avoided unless you are interested in
debugging Guile-PG itself.

@table @code

@item double
NOCREATE.  This can be used to access data of PostgreSQL type
@code{double precision}.

@item char
@itemx name
NOCREATE, INTERNAL.  PostgreSQL actually provides a @code{"char"} type (name
includes the double quotes) that this type (name does not include the double
quotes) mimics.

@item timestamp
This can be used to access data of PostgreSQL type @code{timestamp (0) without
time zone}.

@item inet
@itemx cidr
Guile has no native type that aggregates the address and the netmask, so
Guile-PG defines the Scheme @code{inet} or @code{cidr} object to be a vector
of two elements @code{#(ADDRESS MASKCOUNT)} where @var{address} is a positive
integer zero through #xffffffff (32 bits) and @var{maskcount} is the number of
bits in the netmask.  If @var{maskcount} has value 32, that indicates that
@var{address} is a host address (not a network).

@item inet-host
NOCREATE.  The @code{inet-host} converter can be used to access data of
PostgreSQL type @code{inet} or @code{cidr} when all the data values have a
netmask value of 32.  The Scheme @code{inet-host} object is a positive integer
zero through #xffffffff (32 bits).

@item aclitem
EXPERIMENTAL.  Presently used by module @code{(database postgres-meta)}
in a pass-through (semantically opaque) manner.  (This is another way
of saying we don't know what the hell this is good for, but there it is,
anyway. ;-)

@end table

@node    Defining New Type Converters
@section Defining New Type Converters

To define a new non-array type means associating with the type name a
procedure for converting from a PostgreSQL string representation to a Scheme
object (the @dfn{objectifier}), a procedure to do the conversion in the
opposite direction (the @dfn{stringifier}), and a default string to use if
none is specified (for example, during an @code{INSERT} operation).  For this,
use the @code{define-db-col-type} procedure.

@twerpdoc (define-db-col-type)

To express conversion of arrays (no matter the dimensionality) of non-array
types, use the @code{define-db-col-type-array-variant} procedure.

@twerpdoc (define-db-col-type-array-variant)

@c ---------------------------------------------------------------------------
@node    Column Definitions
@chapter Column Definitions

A column definition, or @dfn{def} for short, associates a column name, its
type and any additional options.  It has the form:

@lisp
(NAME TYPE [OPTIONS...])
@end lisp

@var{name} and @var{type} are symbols specifying the name and type of the
column, respectively (@pxref{Types Conversion}).  @var{options} are strings
passed directly to PostgreSQL as part of a @code{CREATE TABLE} command.  For
example, the status output of the rsync(1) program can be specified by the
form:

@lisp
(define rsync-defs
        '((time            timestamp)
          (error_condition text)
          (files           text[])
          (wrote           int4)          ; bytes
          (read            text[][])
          (rate            float4)
          (total           int4)          ; bytes
          (speedup         float4)
          (etc             int4[])))
@end lisp

Likewise, here is an example that might be useful in keeping a table of
expenses (although probably using @code{float4} is not a good idea for
monetary values):

@lisp
(define expense-ledger-defs
        '((i       serial)
          (date    timestamp)
          (amount  float4)
          (details text[])))
@end lisp

Note that there are no options in these examples.  The components of a def can
be extracted with procedures in the @code{postgres-col-defs} module, which can
be loaded like so:

@lisp
(use-modules ((database postgres-col-defs)
              #:renamer (symbol-prefix-proc 'def:)))
@end lisp

In this example, we use the @code{#:renamer} clause to systematically prefix
"def:" to the names that the client module would see (resulting in
@code{def:column-name} and so on).

@twerpdoc (column-name)
@twerpdoc (type-name)
@twerpdoc (type-options)
@twerpdoc (validate-def)

There are two more convenience procedures, the first one useful in
transforming the results of a query into Scheme objects (@pxref{Result
Transforms}):

@twerpdoc (objectifiers)
@twerpdoc (stringifiers)

@c ---------------------------------------------------------------------------
@node    Result Transforms
@chapter Result Transforms

To support handling of query results in the @dfn{Scheme domain}, Guile-PG
provides various procedures to walk the result object, to extract Scheme
objects from the result object, and to collect these in idiomatic data
structures (such as the association list).

To get started, load the @code{postgres-resx} module:

@lisp
(use-modules (database postgres-resx))
@end lisp

The most basic procedure is @code{for-each-tuple}, useful for quick searches
on the unconverted result strings.

@twerpdoc (for-each-tuple)

The rest of the procedures in this chapter combine conversion of the raw
result strings to Scheme objects, with different collection methods.
@xref{Types Conversion}.  (For access to the unconverted result strings, use
the procedure @code{identity} as the @dfn{objectifier}, which in effect does
no conversion at all.)  The examples are based upon a result object that can
briefly described as:

@itemize
@item two tuples each with two fields
@item field names: "date" and "note"
@item first tuple's date: "2003-01-14 00:00:00-08"
@c                         1042531200
@item first tuple's note: "now", "the present"
@item second tuple's date: "2003-01-13 00:00:00-08"
@c                          1042444800
@item second tuple's note: "yesterday", "the past"
@end itemize

The defs (@pxref{Column Definitions}) for the examples are:

@lisp
(define defs '((date timestamp) (note text[])))
@end lisp

Actually the @code{note} field in its raw form involves curly braces and extra
quoting, but we omit that to reduce clutter.

The @code{result-field->object-list} procedure is useful for single-column
queries.

@twerpdoc (result-field->object-list)

@heading Example
@lisp
(define (1-col result fn type)
  (let ((objectifier (dbcoltype:objectifier (dbcoltype-lookup type))))
    (result-field->object-list result fn objectifier)))

(1-col result 0 'timestamp)
@result{} (1042531200 1042444800)

(1-col result 1 'text[])
@result{} (("now" "the present") ("yesterday" "the past"))
@end lisp

The @code{result->object-FOO} procedures
have the same signature but return the data in different ways.

@twerpdoc (result->object-alist)
@twerpdoc (result->object-alists)
@twerpdoc (result->object-rows)

@heading Example
@lisp
(use-modules ((database postgres-col-defs) #:select (objectifiers)))

(define odefs (objectifiers defs))

(result->object-alist result odefs)
@result{}
((date 1042531200 1042444800)
 (note ("now" "the present") ("yesterday" "the past")))

(result->object-alists result odefs)
@result{}
(((date . 1042531200) (note "now" "the present"))
 ((date . 1042444800) (note "yesterday" "the past")))
@end lisp

@c ---------------------------------------------------------------------------
@node    Single-Table Abstraction
@chapter Single-Table Abstraction

Sometimes it is convenient to focus on a single table, adding rows to it or
drawing queries from it exclusively of any other tables in the database.
Likewise with a view, except that only queries are possible.  This chapter
describes Guile-PG facilities for this kind of use.

To get started, load the @code{postgres-table} module:

@lisp
(use-modules (database postgres-table))
@end lisp

Basically, the @code{pgtable-manager} procedure encapsulates specification,
query and mutation (including create/delete) of a PostgreSQL table; and the
@code{pgtable-worker} procedure encapsulates @code{pgtable-manager}.

@twerpdoc (pgtable-manager)

@twerpdoc (compile-outspec)

@twerpdoc (pgtable-worker)

The other procedures are useful for succintly codifying queries, and
translating the result en mass to Scheme objects.  [NOTE: These will
definitely migrate to other modules at some point before 1.0 release.]

@twerpdoc (tuples-result->table)

@twerpdoc (sql-pre)

The rest of this chapter is an extended example showing some of the uses of
@code{pgtable-manager}.

@lisp
(define m (pgtable-manager "ttn" "guile_pg_demo"
                           '((i          serial)
                             (date       timestamp)
                             (amount     float4)
                             (catcode    text)
                             (details    text[]))))

((m #:create))
@result{} #<PG-RESULT:1:COMMAND_OK:0:0>

(define add (m #:insert-col-values))
(define sel (m #:select))

(add '(date amount) (current-time) 1.98)
@result{} #<PG-RESULT:2:COMMAND_OK:0:0>

(add '(date amount) (current-time) 2.98)
@result{} #<PG-RESULT:3:COMMAND_OK:0:0>

(define (under n)
  (sel '((integer #f (count *)))  ;; outspec
       #:where `(< amount ,n)))   ;; prefix-style expression

(define result (under 2.00))

result
@result{} #<PG-RESULT:4:TUPLES_OK:1:1>

((m #:tuples-result->object-alist) result)
@result{} ((count 1))

((m #:drop))
@result{} (#<PG-RESULT:5:COMMAND_OK:0:0> #<PG-RESULT:6:COMMAND_OK:0:0>)
@end lisp

Two things to note in this example: (1) Both @code{#:create} and @code{#:drop}
invocations evaluate the operating thunk directly (double parentheses); and
(2) The drop returns a list of result values to accomodate the possibility
(shown here) of a @code{serial} column type, which requires an additional drop
of the associated PostgreSQL @dfn{sequence} used to implement the expected
serial behavior.  (As of PostgreSQL 7.x, the sequence name is constructed like
so: @code{TABLENAME_COLNAME_seq}.  For more info, see the PostgreSQL User Guide,
Chapter 3: Data Types.)

@c ---------------------------------------------------------------------------
@node    Introspection
@chapter Introspection

This chapter explains the introspection facilities, which admittedly are not
(yet) very well developed in Guile-PG.  [During the alpha releases, these will
surely change quite a bit; your feedback is welcome.]

To get started, load the @code{postgres-meta} module:

@lisp
(use-modules (database postgres-meta))
@end lisp

The column definitions of an existing table can be discovered to some extent
by the @code{defs-from-psql}, @code{infer-defs} and @code{describe-table!}
procedures, the last one also displaying details on field/column innards.

@twerpdoc (defs-from-psql)
@twerpdoc (infer-defs)
@twerpdoc (describe-table!)

Once you have a set of defs, you can verify that their types are supported by
Guile-PG with the following procedures.

@twerpdoc (check-type/elaborate)
@twerpdoc (strictly-check-types/elaborate!)

@heading Example
@lisp
(define DEFS (defs-from-psql #t "glug" "updok"))

(car DEFS)
@result{} (time timestamp "without time zone not null")

(map type-name DEFS)
@result{} (timestamp integer integer real integer real)

(strictly-check-types/elaborate! "updok" (map type-name DEFS))
@print{}
ERROR: bad "updok" types: (real real)
ABORT: (misc-error)
@end lisp

In this example, we use the external program @file{psql} to find out the defs
for the table @code{updok} in database @code{glug}; use @code{type-name} to
get the types (@pxref{Column Definitions}); and finally check to see which
ones, if any, are unknown to Guile-PG.  The error output lists @code{real}
twice because two of the @code{DEFS} have that type.

@c ---------------------------------------------------------------------------
@node    Easy Interaction
@chapter Easy Interaction

Sometimes you just want to poke around manually, interacting with a database
connection by typing in exploratory commands, and the external command-line
program psql(1) does not provide enough insight or customizability (or perhaps
is not available).  This chapter presents an alternative method for running
such a repl (read-eval-print loop).

To get started, load the @code{postgres-gxrepl} module:

@lisp
(use-modules (database postgres-gxrepl))
@end lisp

This provides the procedure @code{gxrepl}.  The ``gx'' stands for ``guile
extensible'', which is not the case at the moment, but we have great and
humble plans for this module...

@twerpdoc (gxrepl)

Most comma commands are relatively self-explantory, with guidance from
@code{,help}.  The rest of this chapter delves into some of the more
arcane commands.

Primarily, the @dfn{fixed-part select} is an exploratory type of interaction
where you can @dfn{fix} certain parts of a normal @code{select} query so that
you can concentrate on varying the rest.

For example:

@example
,fix #:from icbmcoords
Use the table `icbmcoords' (with columns `one', `two' and `importance').

,fsel one two #:where (< 9 importance)
Select some tuples.

,fix #:cols ("latitude" . one) ("longitude" . two)
More descriptive titles.

,fix #:where (< 9 importance) (> 3 importance)
We are scatterbrained, which helps ameliorate the evilness.

,fix #:where/combiner or
Uh oh, wits recovered, we once again are a menace.
@end example

For comparison, here is the last example again, recast into SQL:

@example
SELECT one AS "latitude", two AS "longitude"
  FROM icbmcoords
 WHERE ((9 < importance) OR (3 > importance));
@end example

@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@c + @node       Concept Index
@c + @unnumbered Concept Index
@c +
@c + @printindex cp

@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node       Procedure Index
@unnumbered Procedure Index

@printindex fn

@node       Error Index
@unnumbered Error Index

@xref{Retrieving Data}, for info on @code{pg-error-message}.
These errors, on the other hand, are not handled by that mechanism.

@printindex er

@bye
