
- 0.18

  + Add proc `pgtable-worker' to (database postgres-table)

  + Remove variables
      PGRES_EMPTY_QUERY
      PGRES_COMMAND_OK
      PGRES_TUPLES_OK
      PGRES_COPY_OUT
      PGRES_COPY_IN
      PGRES_BAD_RESPONSE
      PGRES_NONFATAL_ERROR
      PGRES_FATAL_ERROR
    Code should be using the symbols (by the same name) instead by now.

  + Remove "def:" procs from (database postgres-table)
      def:col-name
      def:type-name
      def:type-options
    Still available from (database postgres-col-defs) w/o "def:" prefix.

  - Review for dangerous construct: return scm_cons (scm_cons (...))

    Garbage collection can zonk intermediate values leading to loss of
    integrity (and thus bugs).  Better to use strictly imperative style
    and use C auto vars for intermediate values, even if it is ugly.

  + Review SCM_ROSTRINGs used as null-terminated strings

  + Clean up module (database postgres-meta)
    + Replace display-table with pg-print
    + Add proc to parse output from: psql -c '\d TABLE'
    + Add procs to validate types and extend Guile-PG array variants
    + Document new procs
    + Add necessary types to handle PostgreSQL 7.3.5 pg_class

  - Write tests for non-blocking query support

  + Implement these calls:

    + Asynchronous version of PQgetline

          int PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)

    + Non-blocking query support

          int PQsendQuery (PGconn *conn, const char *query)
          PGresult *PQgetResult (PGconn *conn)
          int PQconsumeInput (PGconn *conn)
          int PQisBusy(PGconn *conn)
          int PQrequestCancel(PGconn *conn)

    + PQconndefaults

        PQconninfoOption *PQconndefaults(void)
        struct PQconninfoOption { ... }

  + Use GNU style curly-brace placement in C code


- Eventually

  - Implement these calls:

          int PQsocket(PGconn *conn)
                 Returns a socket fd for the connection to the backend.

  - Regularize error handling.

  - Enable post-install maintenance of (database postgres-meta).
    - Write/document proc that updates *class-defs*.
    - Also use it at "make" time.

  - Remove compiled proc `pg-oid-status'.

  - Remove compiled/uncompiled synchronization procs.

    These are non-critical cruft from when sanity checking was necessary:

	pg-guile-pg-version
	pg-guile-pg-module-version
	pg-guile-pg-module-config-stamp

    Users who want to track changes should check features directly instead
    of version numbers and time stamps.

  - Add to the manual a section giving an overview of using large-objects.

    This must explain the ideas of OID's as references to objects.  Also we
    need examples of using lo-streams. Perhaps a scheme implementation of
    lo-export and lo-import and, just for fun, a demonstration of executing
    scheme code contained in a large object.  There should also be an example
    of updating a table with a large number of large objects. Perhaps it could
    take a directory with lots of binary files in it and store each file in a
    large object in a table listing the names of the files.

  - Incorporate scheme result-iterator/stream procs.

    This should provide query-level functions like (pg:for-each) which
    iterates over a set of tuples returned from a query. Also provide a
    streams interface so that (pg:stream-cdr) and (pg:stream-car) return
    tuples.

  - Add a (pg:quote-sql-string-literal) procedure.

    This should take an arbitrary scheme string and return it suitably quoted
    so that it can appear safely inside single quotes in an sql statement. I
    think this should be written in C so that it's fast. To write it we need
    to make a careful examination of what characters are special in sql
    string-literals. These include, but may not be limited to: backslash,
    single quote, carriage return, linefeed, tab.

  - Use a better method to check that libpq-fe.h and libpq/libpq-fs.h are
    on the -I path.

    The current scheme uses ./configure options --with-libpq and
    --with-libpq-includes and --with-libpq-lib, but they're awful and the GNU
    coding standards say --with options should only be used to include
    optional components in the build. It's difficult to argue that libpq is
    optional because the interface can't be built without it.

    But apparently this is an acceptable way to use the --with flags, so
    that's what we should do. Jim Blandy says we should also look in 'obvious
    places' for the headers and libraries.



	Local Variables:
	mode: outline
	outline-regexp: "\\([ ][ ]\\)*[-+] "
	fill-column: 78
	End:
