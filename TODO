
- 0.18

  + Remove variables
      PGRES_EMPTY_QUERY
      PGRES_COMMAND_OK
      PGRES_TUPLES_OK
      PGRES_COPY_OUT
      PGRES_COPY_IN
      PGRES_BAD_RESPONSE
      PGRES_NONFATAL_ERROR
      PGRES_FATAL_ERROR
    Code should be using the symbols (by the same name) instead by now.

  + Remove "def:" procs from (database postgres-table)
      def:col-name
      def:type-name
      def:type-options
    Still available from (database postgres-col-defs) w/o "def:" prefix.

  - Review for dangerous construct: return scm_cons (scm_cons (...))

    Garbage collection can zonk intermediate values leading to loss of
    integrity (and thus bugs).  Better to use strictly imperative style
    and use C auto vars for intermediate values, even if it is ugly.

  - Review SCM_ROSTRINGs used as null-terminated strings

    We need to make sure they aren't substrings.

  + Clean up module (database postgres-meta)
    + Replace display-table with pg-print
    + Add proc to parse output from: psql -c '\d TABLE'
    + Add procs to validate types and extend Guile-PG array variants
    + Document new procs
    + Add necessary types to handle PostgreSQL 7.3.5 pg_class

  - Write tests for non-blocking query support

  - Implement these calls:

    + Asynchronous version of PQgetline

          int      PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)

    - Non-blocking query support

          int PQsendQuery (PGconn *conn, const char *query)

          PGresult *PQgetResult (PGconn *conn)
                 Returns a pointer to a result or NULL if no more
                  results are due from the given connection.

          int PQconsumeInput (PGconn *conn)
                 Returns 1 if OK, 0 otherwise.

          int PQisBusy(PGconn *conn)
                 Returns TRUE if there is data waiting for PQconsumeInput,
                 FALSE otherwise.

          int PQsocket(PGconn *conn)
                 Returns a socket fd for the connection to the backend.

          int PQrequestCancel(PGconn *conn)

      The return value is TRUE if the cancel request was successfully
      dispatched, FALSE if not.  (If not, PQerrorMessage tells why not.)
      Successful dispatch is no guarantee that the request will have any
      effect, however.  Regardless of the return value of PQrequestCancel, the
      application must continue with the normal result-reading sequence using
      PQgetResult.  If the cancellation is effective, the current query will
      terminate early and return an error result.  If the cancellation fails
      (say because the backend was already done processing the query), then
      there will be no visible result at all.

      Note that if the current query is part of a transaction, cancellation
      will abort the whole transaction.

    + PQconndefaults

        PQconninfoOption *PQconndefaults(void)

        struct PQconninfoOption {
            char   *keyword;   /* The keyword of the option */
            char   *envvar;    /* Fallback environment variable name */
            char   *compiled;  /* Fallback compiled in default value */
            char   *val;       /* Option's value */
            char   *label;     /* Label for field in connect dialog */
            char   *dispchar;  /* Character to display for this field
                                  in a connect dialog. Values are:
                                  ""        Display entered value as is
                                  "*"       Password field - hide value
                                  "D"       Debug options - don't
                                            create a field by default */
            int     dispsize;  /* Field size in characters for dialog */
        };

      Returns the address of the connection options structure.  This may be
      used to determine all possible PQconnectdb options and their current
      default values.  The return value points to an array of PQconninfoOption
      structs, which ends with an entry having a NULL keyword pointer.  Note
      that the default values ("val" fields) will depend on environment
      variables and other context. Callers must treat the connection options
      data as read-only.

  + Use GNU style curly-brace placement in C code


- Eventually

  - Regularize error handling.

  - Enable post-install maintenance of (database postgres-meta).
    - Write/document proc that updates *class-defs*.
    - Also use it at "make" time.

  - Remove compiled proc `pg-oid-status'.

  - Remove compiled/uncompiled synchronization procs.

    These are non-critical cruft from when sanity checking was necessary:

	pg-guile-pg-version
	pg-guile-pg-module-version
	pg-guile-pg-module-config-stamp

    Users who want to track changes should check features directly instead
    of version numbers.

  - Add to the manual a section giving an overview of using large-objects.

    This must explain the ideas of OID's as references to objects.  Also we
    need examples of using lo-streams. Perhaps a scheme implementation of
    lo-export and lo-import and, just for fun, a demonstration of executing
    scheme code contained in a large object.  There should also be an example
    of updating a table with a large number of large objects. Perhaps it could
    take a directory with lots of binary files in it and store each file in a
    large object in a table listing the names of the files.

  - Incorporate scheme result-iterator/stream procs.

    This should provide query-level functions like (pg:for-each) which
    iterates over a set of tuples returned from a query. Also provide a
    streams interface so that (pg:stream-cdr) and (pg:stream-car) return
    tuples.

  - Add a (pg:quote-sql-string-literal) procedure.

    This should take an arbitrary scheme string and return it suitably quoted
    so that it can appear safely inside single quotes in an sql statement. I
    think this should be written in C so that it's fast. To write it we need
    to make a careful examination of what characters are special in sql
    string-literals. These include, but may not be limited to: backslash,
    single quote, carriage return, linefeed, tab.

  - Use a better method to check that libpq-fe.h and libpq/libpq-fs.h are
    on the -I path.

    The current scheme uses ./configure options --with-libpq and
    --with-libpq-includes and --with-libpq-lib, but they're awful and the GNU
    coding standards say --with options should only be used to include
    optional components in the build. It's difficult to argue that libpq is
    optional because the interface can't be built without it.

    But apparently this is an acceptable way to use the --with flags, so
    that's what we should do. Jim Blandy says we should also look in 'obvious
    places' for the headers and libraries.



	Local Variables:
	mode: outline
	outline-regexp: "\\([ ][ ]\\)*[-+] "
	fill-column: 78
	End:
