
- 0.17

  + Use module abstraction for shared object libraries.

  + Install compiled modules under ${GUILE_SITE} and ${GUILE_LIBSITE}.

  - Add convenience Makefile target: clean-nonmodule-guile-pg.

  + Fix incorrect objectifiers selection bug in pgtable-manager.

    For `tuples-result->object-alist' and `tuples-result->alists'
    sub-procs, the `objectifiers' passed to `result->object-alist'
    and `result->object-alists', respectively, is not trimmed or
    otherwise qualified to match the selected columns.

  + Add tests for pg-print and pg-make-print-options.

  + Use tmpfile(3) for pg_print.

  + Review error handling; document.

  + Implement these calls:

    + client encoding

      int PQclientEncoding (const PGconn *conn);
      int PQsetClientEncoding (PGconn *conn, const char *encoding);

    + PQsetNoticeProcessor

      Control reporting of notice and warning messages generated by libpq.

           void PQsetNoticeProcessor (PGconn * conn,
                   void (*noticeProcessor) (void * arg, const char * message),
                   void * arg);

      Actually, PQsetNoticeProcessor is encapsulated and the programming
      interface is different: `pg-set-notice-out!'.

    + PQnotifies

      PQnotifies returns the next notification from a list of unhandled
      notification messages received from the backend.  Returns NULL if there
      are no pending notifications.  Once a notification is returned from
      PQnotifies, it is considered handled and will be removed from the list
      of notifications.

           PGnotify* PQnotifies(PGconn *conn);

           typedef struct pgNotify {
              char        relname[NAMEDATALEN];       /* name of relation
                                                            * containing data */
              int         be_pid;                     /* process id of backend */
           } PGnotify;

      After processing a PGnotify object returned by PQnotifies, be sure to
      free it with free() to avoid a memory leak.

      PQnotifies() does not actually read backend data; it just returns
      messages previously absorbed by another libpq function.  In prior
      releases of libpq, the only way to ensure timely receipt of NOTIFY
      messages was to constantly submit queries, even empty ones, and then
      check PQnotifies() after each PQexec().  While this still works, it is
      deprecated as a waste of processing power.  A better way to check for
      NOTIFY messages when you have no useful queries to make is to call
      PQconsumeInput(), then check PQnotifies().  You can use select(2) to
      wait for backend data to arrive, thereby using no CPU power unless there
      is something to do.  Note that this will work OK whether you use
      PQsendQuery/PQgetResult or plain old PQexec for queries.  You should,
      however, remember to check PQnotifies() after each PQgetResult or PQexec
      to see if any notifications came in during the processing of the query.


- 0.18

  - Removal of variables
      PGRES_EMPTY_QUERY
      PGRES_COMMAND_OK
      PGRES_TUPLES_OK
      PGRES_COPY_OUT
      PGRES_COPY_IN
      PGRES_BAD_RESPONSE
      PGRES_NONFATAL_ERROR
      PGRES_FATAL_ERROR
    Code should be using the symbols (by the same name) instead by now.

  - Removal of "def:" procs from (database postgres-table)
      def:col-name
      def:type-name
      def:type-options
    Still available from (database postgres-col-defs) w/o "def:" prefix.

  - Review for dangerous construct: return scm_cons (scm_cons (...))

    Garbage collection can zonk intermediate values leading to loss of
    integrity (and thus bugs).  Better to use strictly imperative style
    and use C auto vars for intermediate values, even if it is ugly.


- Eventually

  - Regularize error handling.

  - Remove compiled/uncompiled synchronization procs.

    These are non-critical cruft from when sanity checking was necessary:

	pg-guile-pg-version
	pg-guile-pg-module-version
	pg-guile-pg-module-config-stamp

    Users who want to track changes should check features directly instead
    of version numbers.

  - Fix places where SCM_ROSTRINGs are treated as null-terminated strings.
    We need to make sure they aren't substrings.

  - Implement these calls:

    - PQclear

      void PQclear (PGresult *res);

    - PQfinish

      void PQfinish (PGconn *conn);

    - PQconndefaults

        PQconninfoOption *PQconndefaults(void)

        struct PQconninfoOption {
            char   *keyword;   /* The keyword of the option */
            char   *envvar;    /* Fallback environment variable name */
            char   *compiled;  /* Fallback compiled in default value */
            char   *val;       /* Option's value */
            char   *label;     /* Label for field in connect dialog */
            char   *dispchar;  /* Character to display for this field
                                  in a connect dialog. Values are:
                                  ""        Display entered value as is
                                  "*"       Password field - hide value
                                  "D"       Debug options - don't
                                            create a field by default */
            int     dispsize;  /* Field size in characters for dialog */
        };

      Returns the address of the connection options structure.  This may be
      used to determine all possible PQconnectdb options and their current
      default values.  The return value points to an array of PQconninfoOption
      structs, which ends with an entry having a NULL keyword pointer.  Note
      that the default values ("val" fields) will depend on environment
      variables and other context. Callers must treat the connection options
      data as read-only.

    - Asynchronous version of PQgetline

          int      PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)

    - Non-blocking query support

          int PQsendQuery (PGconn *conn, const char *query)

          PGresult *PQgetResult (PGconn *conn)
                 Returns a pointer to a result or NULL if no more
                  results are due from the given connection.

          int PQconsumeInput (PGconn *conn)
                 Returns 1 if OK, 0 otherwise.

          int PQisBusy(PGconn *conn)
                 Returns TRUE if there is data waiting for PQconsumeInput,
                 FALSE otherwise.

          int PQsocket(PGconn *conn)
                 Returns a socket fd for the connection to the backend.

          int PQrequestCancel(PGconn *conn)

      The return value is TRUE if the cancel request was successfully
      dispatched, FALSE if not.  (If not, PQerrorMessage tells why not.)
      Successful dispatch is no guarantee that the request will have any
      effect, however.  Regardless of the return value of PQrequestCancel, the
      application must continue with the normal result-reading sequence using
      PQgetResult.  If the cancellation is effective, the current query will
      terminate early and return an error result.  If the cancellation fails
      (say because the backend was already done processing the query), then
      there will be no visible result at all.

      Note that if the current query is part of a transaction, cancellation
      will abort the whole transaction.

  - Add to the manual a section giving an overview of using large-objects.

    This must explain the ideas of OID's as references to objects.  Also we
    need examples of using lo-streams. Perhaps a scheme implementation of
    lo-export and lo-import and, just for fun, a demonstration of executing
    scheme code contained in a large object.  There should also be an example
    of updating a table with a large number of large objects. Perhaps it could
    take a directory with lots of binary files in it and store each file in a
    large object in a table listing the names of the files.

  - Incorporate scheme result-iterator/stream procs.

    This should provide query-level functions like (pg:for-each) which
    iterates over a set of tuples returned from a query. Also provide a
    streams interface so that (pg:stream-cdr) and (pg:stream-car) return
    tuples.

  - Add a (pg:quote-sql-string-literal) procedure.

    This should take an arbitrary scheme string and return it suitably quoted
    so that it can appear safely inside single quotes in an sql statement. I
    think this should be written in C so that it's fast. To write it we need
    to make a careful examination of what characters are special in sql
    string-literals. These include, but may not be limited to: backslash,
    single quote, carriage return, linefeed, tab.

  - Use a better method to check that libpq-fe.h and libpq/libpq-fs.h are
    on the -I path.

    The current scheme uses ./configure options --with-libpq and
    --with-libpq-includes and --with-libpq-lib, but they're awful and the GNU
    coding standards say --with options should only be used to include
    optional components in the build. It's difficult to argue that libpq is
    optional because the interface can't be built without it.

    But apparently this is an acceptable way to use the --with flags, so
    that's what we should do. Jim Blandy says we should also look in 'obvious
    places' for the headers and libraries.

  - Packaging

    - guile-pg.spec for Red Hat RPM

    - debian/ et al for Debian


	Local Variables:
	mode: outline
	outline-regexp: "\\([ ][ ]\\)*[-+] "
	fill-column: 78
	End:
