;; $Id$
;;    Guile-pg - A Guile interface to PostgreSQL
;;    Copyright (C) 1999,2000 The Free Software Foundation
;;
;;    This program is free software; you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation; either version 2 of the License, or
;;    (at your option) any later version.
;;
;;    This program is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with this program; if not, write to the Free Software
;;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;;
;;    Guile-pg was written by Ian Grant <Ian.Grant@cl.cam.ac.uk>

;; (define-module (guile-user))

;; Load the C interface functions

(if (not (defined? 'pg-guile-pg-version)) ;; Unless already loaded (static) ...
  (dynamic-call "init_postgres" (dynamic-link "libpostgres.so")))

(define-module (database postgres))

(define (list->sqlcmd lst)
  (define (cmd->string cmd)
    (cond ((string? cmd) (sqlquote cmd))
          ((number? cmd) (number->string cmd))
          ((symbol? cmd) (symbol->string cmd))))
    (if (null? lst) ""
      (let ((cmd (car lst)))
        (string-append
          (cond ((pair? cmd) (string-append "(" (list->sqlcmd cmd) ")"))
                (else (string-append (cmd->string cmd))))
	  (let ((tail (cdr lst)))
	    (if (not (null? tail))
	        (string-append " " (list->sqlcmd tail)) ""))))))

(define (sqlquote str)
  (string-append "'" (sqlescape str) "'"))

(define (sqlescape str)
  (let* ((retlst '())
         (push (lambda (c) (set! retlst (cons c retlst)))))
    (for-each (lambda (chr)
                (if (or (eqv? chr #\\) (eqv? chr #\')) (push #\\) ())
                (push chr))
      (string->list str))
    (list->string (reverse retlst))))

(define (displaysql lst)
  (display (list->sqlcmd lst))
  (newline))
(define (as-string obj)
  (cond ((string? obj) obj)
        ((char? obj) (make-string 1 obj))
        ((symbol? obj) (symbol->string obj))
        ((number? obj) (number->string obj))
        ((procedure? obj) (as-string (obj)))
        ((pair? obj) (interpolate-list "(" " " ")" 
                       (lambda (x) (as-string x)) obj))
        (else "?as-string")))

(define (interpolate-list afore twixt aft proc lst)
  (define (iter lst)
    (let ((elt (car lst))
          (tail (cdr lst)))
       (string-append (proc elt)
         (if (not (null? tail))
           (string-append (as-string twixt) (iter tail))
           (as-string aft)))))
  (string-append (as-string afore) (iter lst)))

(define-public (pg-module-config-stamp) "@GUILE_PG_STAMP@")
(define-public (pg-guile-pg-module-version) "@VERSION@")
(define-public (pg-module-rcsid) "$Id$")

(define-public (pg-make-table! conn tablename fields)
  (let ((sql-string (string-append
                      "CREATE TABLE " tablename " "
                      (interpolate-list "(" ", " ")" 
                        (lambda (p)
                          (string-append 
                            (as-string (car p)) " " (as-string (cdr p))))
                        fields))))
       (pg:exec conn sql-string)))

(define-public (pg-insert-record! conn tablename record)
  (let ((sql-string (string-append
                      "INSERT INTO " tablename " "
                      (interpolate-list "(" ", " ")" 
                        (lambda (p)
                          (string-append (as-string (car p)) " "))
                        record)
                      " VALUES "
                      (interpolate-list "(" ", " ")" 
                        (lambda (p)
                          (string-append (as-string (cdr p)) " "))
                        record))))
       (pg:exec conn sql-string)))

(define-public (pg-fnames result)
  (let ((nfields (pg:nfields result)))
    (define (iter i)
      (if (= i nfields) '()
          (cons (pg:fname result i) (iter (+ i 1)))))
    (iter 0)))

(define-public (pg-getvalues result tuple)
  (let ((nfields (pg:nfields result)))
    (define (iter i)
      (if (= i nfields) '()
          (cons (pg:getvalue result tuple i) (iter (+ i 1)))))
    (iter 0)))

(define-public (pg-gettuple result tuple)
  (map (lambda (n v) (cons (string->symbol n) v))
       (pg:fnames result)
       (pg:getvalues result tuple)))

(define-public (pg-for-each proc result)
  (let ((ntuples (pg:ntuples result)))
    (define (iter i)
      (cond ((= i ntuples) ntuples)
            (else (proc (pg:gettuple result i))
                  (iter (+ i 1)))))
    (iter 0)))

(define-public (pg-tuples result)
  (let ((ntuples (pg:ntuples result)))
    (define (iter i)
      (cond ((= i ntuples) '())
            (else (cons (pg:gettuple result i)
                  (iter (+ i 1))))))
    (iter 0)))

